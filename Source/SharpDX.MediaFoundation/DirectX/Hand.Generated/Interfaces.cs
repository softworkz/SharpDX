// Copyright (c) 2010-2014 SharpDX - Alexandre Mutel
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Types declaration for SharpDX.MediaFoundation.DirectX namespace.
//     This code was generated by a tool.
//     Date : 6/17/2016 5:56:11 PM
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Security;
// ReSharper disable RedundantNameQualifier
#if DESKTOP_APP
namespace SharpDX.MediaFoundation.DirectX {

// Disable warning : XML comment is not placed on a valid language element
#pragma warning disable 419
#pragma warning disable 1587
#pragma warning disable 1574
    /// <summary>	
    /// <p>Enables two threads to share the same Direct3D 9 device, and provides access to the DirectX Video Acceleration (DXVA) features of the device.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface is exposed by the Direct3D Device Manager. To create the Direct3D device manager, call <strong><see cref="SharpDX.MediaFoundation.DirectX.DXVAFactory.CreateDirect3DDeviceManager9"/></strong>.</p><p>To get this interface from the Enhanced Video Renderer (EVR), call <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong>. The service <see cref="System.Guid"/> is <strong><see cref="SharpDX.MediaFoundation.MediaServiceKeys.VideoAcceleration"/></strong>. For the DirectShow EVR filter, call <strong>GetService</strong> on the filter's pins.</p><p>The Direct3D Device Manager supports Direct3D 9 devices only. It does not support DXGI devices.</p><p>Windows Store apps must use <strong>IMFDXGIDeviceManager</strong> and Direct3D 11 Video APIs. </p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDeviceManager9']/*"/>	
    /// <msdn-id>ms704727</msdn-id>	
    /// <unmanaged>IDirect3DDeviceManager9</unmanaged>	
    /// <unmanaged-short>IDirect3DDeviceManager9</unmanaged-short>	
    [Guid("a0cade0f-06d5-4cf4-a1c7-f3cdd725aa75")]
    public partial class Direct3DDeviceManager : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.DirectX.Direct3DDeviceManager"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Direct3DDeviceManager(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.DirectX.Direct3DDeviceManager"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.MediaFoundation.DirectX.Direct3DDeviceManager(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.DirectX.Direct3DDeviceManager(nativePointer);
		}
        
        
        /// <summary>	
        /// <p> Sets the Direct3D device or notifies the device manager that the Direct3D device was reset.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface of the Direct3D device.</p> </dd></param>	
        /// <param name="resetToken"><dd> <p>Token received in the <em>pResetToken</em> parameter of the <strong><see cref="SharpDX.MediaFoundation.DirectX.DXVAFactory.CreateDirect3DDeviceManager9"/></strong> function.</p> </dd></param>	
        /// <returns><p>The method returns an <see cref="SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid token</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/></strong></dt> </dl> </td><td> <p>Direct3D device error.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>When you first create the Direct3D device manager, call this method with a reference to the Direct3D device. The device manager does not create the device; the caller must provide the device reference initially.</p><p>Also call this method if the Direct3D device becomes lost and you need to reset the device or create a new device. This occurs if <strong><see cref="SharpDX.Direct3D9.Device.TestCooperativeLevel"/></strong> returns <see cref="SharpDX.Direct3D9.ResultCode.DeviceLost"/> or <see cref="SharpDX.Direct3D9.ResultCode.DeviceNotReset"/>. For more information about lost devices, see the Direct3D documentation.</p><p>The <em>resetToken</em> parameter ensures that only the component which originally created the device manager can invalidate the current device.</p><p>If this method succeeds, all open device handles become invalid.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDeviceManager9::ResetDevice']/*"/>	
        /// <msdn-id>ms693525</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDeviceManager9::ResetDevice([In] IDirect3DDevice9* pDevice,[In] unsigned int resetToken)</unmanaged>	
        /// <unmanaged-short>IDirect3DDeviceManager9::ResetDevice</unmanaged-short>	
        public void ResetDevice(SharpDX.Direct3D9.Device deviceRef, int resetToken) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), resetToken,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Gets a handle to the Direct3D device. </p>	
        /// </summary>	
        /// <param name="hDeviceRef"><dd> <p>Receives the device handle.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>DXVA2_E_NOT_INITIALIZED</strong></dt> </dl> </td><td> <p>The Direct3D device manager was not initialized. The owner of the device must call <strong><see cref="SharpDX.MediaFoundation.DirectX.Direct3DDeviceManager.ResetDevice"/></strong>.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>To get the Direct3D device's <strong><see cref="SharpDX.Direct3D9.Device"/></strong> reference, call <strong><see cref="SharpDX.MediaFoundation.DirectX.Direct3DDeviceManager.LockDevice"/></strong> with the handle returned in <em>phDevice</em>. Close the device handle when you are done using it, by calling <strong><see cref="SharpDX.MediaFoundation.DirectX.Direct3DDeviceManager.CloseDeviceHandle"/></strong>.</p><p>To test whether a device handle is still valid, call <strong><see cref="SharpDX.MediaFoundation.DirectX.Direct3DDeviceManager.TestDevice"/></strong>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDeviceManager9::OpenDeviceHandle']/*"/>	
        /// <msdn-id>ms698976</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDeviceManager9::OpenDeviceHandle([Out] void** phDevice)</unmanaged>	
        /// <unmanaged-short>IDirect3DDeviceManager9::OpenDeviceHandle</unmanaged-short>	
        public void OpenDeviceHandle(out System.IntPtr hDeviceRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* hDeviceRef_ = &hDeviceRef)
                    __result__= 
    				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, hDeviceRef_,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Closes a Direct3D device handle. Call this method to release a device handle retrieved by the <strong><see cref="SharpDX.MediaFoundation.DirectX.Direct3DDeviceManager.OpenDeviceHandle"/></strong> method. </p>	
        /// </summary>	
        /// <param name="hDevice">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_HANDLE</strong></dt> </dl> </td><td> <p>Invalid handle.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDeviceManager9::CloseDeviceHandle']/*"/>	
        /// <msdn-id>ms697332</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDeviceManager9::CloseDeviceHandle([In] void* hDevice)</unmanaged>	
        /// <unmanaged-short>IDirect3DDeviceManager9::CloseDeviceHandle</unmanaged-short>	
        public void CloseDeviceHandle(System.IntPtr hDevice) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)hDevice,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Tests whether a Direct3D device handle is valid. </p>	
        /// </summary>	
        /// <param name="hDevice"><dd> <p>Handle to a Direct3D device. To get a device handle, call <strong><see cref="SharpDX.MediaFoundation.DirectX.Direct3DDeviceManager.OpenDeviceHandle"/></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The device handle is valid.</p> </td></tr> <tr><td> <dl> <dt><strong>E_HANDLE</strong></dt> </dl> </td><td> <p>The specified handle is not a Direct3D device handle.</p> </td></tr> <tr><td> <dl> <dt><strong>DXVA2_E_NEW_VIDEO_DEVICE</strong></dt> </dl> </td><td> <p>The device handle is invalid.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the method returns DXVA2_E_NEW_VIDEO_DEVICE, call <strong><see cref="SharpDX.MediaFoundation.DirectX.Direct3DDeviceManager.CloseDeviceHandle"/></strong> to close the handle and then call <strong>OpenDeviceHandle</strong> again to get a new handle. The <strong><see cref="SharpDX.MediaFoundation.DirectX.Direct3DDeviceManager.ResetDevice"/></strong> method invalidates all open device handles.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDeviceManager9::TestDevice']/*"/>	
        /// <msdn-id>ms704778</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDeviceManager9::TestDevice([In] void* hDevice)</unmanaged>	
        /// <unmanaged-short>IDirect3DDeviceManager9::TestDevice</unmanaged-short>	
        public void TestDevice(System.IntPtr hDevice) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)hDevice,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Gives the caller exclusive access to the Direct3D device. </p>	
        /// </summary>	
        /// <param name="hDevice"><dd> <p>A handle to the Direct3D device. To get the device handle, call <strong><see cref="SharpDX.MediaFoundation.DirectX.Direct3DDeviceManager.OpenDeviceHandle"/></strong>. </p> </dd></param>	
        /// <param name="deviceOut"><dd> <p> Receives a reference to the device's <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface. </p> </dd></param>	
        /// <param name="fBlock"><dd> <p> Specifies whether to wait for the device lock. If the device is already locked and this parameter is <strong>TRUE</strong>, the method blocks until the device is unlocked. Otherwise, if the device is locked and this parmater is <strong><see cref="SharpDX.Result.False"/></strong>, the method returns immediately with the error code <strong>DXVA2_E_VIDEO_DEVICE_LOCKED</strong>. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>DXVA2_E_NEW_VIDEO_DEVICE</strong></dt> </dl> </td><td> <p> The device handle is invalid. </p> </td></tr> <tr><td> <dl> <dt><strong>DXVA2_E_NOT_INITIALIZED</strong></dt> </dl> </td><td> <p> The Direct3D device manager was not initialized. The owner of the device must call <strong><see cref="SharpDX.MediaFoundation.DirectX.Direct3DDeviceManager.ResetDevice"/></strong>. </p> </td></tr> <tr><td> <dl> <dt><strong>DXVA2_E_VIDEO_DEVICE_LOCKED</strong></dt> </dl> </td><td> <p> The device is locked and <em>fBlock</em> is <strong><see cref="SharpDX.Result.False"/></strong>. </p> </td></tr> <tr><td> <dl> <dt><strong>E_HANDLE</strong></dt> </dl> </td><td> <p> The specified handle is not a Direct3D device handle. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> When you are done using the Direct3D device, call <strong><see cref="SharpDX.MediaFoundation.DirectX.Direct3DDeviceManager.UnlockDevice"/></strong> to unlock to the device. </p><p> If the method returns <strong>DXVA2_E_NEW_VIDEO_DEVICE</strong>, call <strong><see cref="SharpDX.MediaFoundation.DirectX.Direct3DDeviceManager.CloseDeviceHandle"/></strong> to close the handle and then call <strong>OpenDeviceHandle</strong> again to get a new handle. The <strong><see cref="SharpDX.MediaFoundation.DirectX.Direct3DDeviceManager.ResetDevice"/></strong> method invalidates all open device handles. </p><p> If <em>fBlock</em> is <strong>TRUE</strong>, this method can potentially deadlock. For example, it will deadlock if a thread calls <strong>LockDevice</strong> and then waits on another thread that calls <strong>LockDevice</strong>. It will also deadlock if a thread calls <strong>LockDevice</strong> twice without calling <strong>UnlockDevice</strong> in between. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDeviceManager9::LockDevice']/*"/>	
        /// <msdn-id>ms697056</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDeviceManager9::LockDevice([In] void* hDevice,[Out] IDirect3DDevice9** ppDevice,[In] BOOL fBlock)</unmanaged>	
        /// <unmanaged-short>IDirect3DDeviceManager9::LockDevice</unmanaged-short>	
        public void LockDevice(System.IntPtr hDevice, out SharpDX.Direct3D9.Device deviceOut, SharpDX.Mathematics.Interop.RawBool fBlock) {
            unsafe {
                IntPtr deviceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.MediaFoundation.LocalInterop.Calliint49(_nativePointer, (void*)hDevice, &deviceOut_, fBlock,((void**)(*(void**)_nativePointer))[7]);		
                deviceOut= (deviceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Device(deviceOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Unlocks the Direct3D device. Call this method to release the device after calling <strong><see cref="SharpDX.MediaFoundation.DirectX.Direct3DDeviceManager.LockDevice"/></strong>.</p>	
        /// </summary>	
        /// <param name="hDevice">No documentation.</param>	
        /// <param name="fSaveState">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The specified device handle is not locked, or is not a valid handle.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDeviceManager9::UnlockDevice']/*"/>	
        /// <msdn-id>ms704707</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDeviceManager9::UnlockDevice([In] void* hDevice,[In] BOOL fSaveState)</unmanaged>	
        /// <unmanaged-short>IDirect3DDeviceManager9::UnlockDevice</unmanaged-short>	
        public void UnlockDevice(System.IntPtr hDevice, SharpDX.Mathematics.Interop.RawBool fSaveState) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.MediaFoundation.LocalInterop.Calliint16(_nativePointer, (void*)hDevice, fSaveState,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Gets a DirectX Video Acceleration (DXVA) service interface. </p>	
        /// </summary>	
        /// <param name="hDevice"><dd> <p> A handle to a Direct3D device. To get a device handle, call <strong><see cref="SharpDX.MediaFoundation.DirectX.Direct3DDeviceManager.OpenDeviceHandle"/></strong>. </p> </dd></param>	
        /// <param name="riid"><dd> <p> The interface identifier (IID) of the requested interface. The Direct3D device might support the following DXVA service interfaces: </p> <ul> <li> <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDecoderService"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoProcessorService"/></strong> </li> </ul> </dd></param>	
        /// <param name="serviceOut"><dd> <p> Receives a reference to the requested interface. The caller must release the interface. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>DXVA2_E_NEW_VIDEO_DEVICE</strong></dt> </dl> </td><td> <p> The device handle is invalid. </p> </td></tr> <tr><td> <dl> <dt><strong>DXVA2_E_NOT_AVAILABLE</strong></dt> </dl> </td><td> <p> The Direct3D device does not support video acceleration. </p> </td></tr> <tr><td> <dl> <dt><strong>DXVA2_E_NOT_INITIALIZED</strong></dt> </dl> </td><td> <p> The Direct3D device manager was not initialized. The owner of the device must call <strong><see cref="SharpDX.MediaFoundation.DirectX.Direct3DDeviceManager.ResetDevice"/></strong>. </p> </td></tr> <tr><td> <dl> <dt><strong>E_HANDLE</strong></dt> </dl> </td><td> <p> The specified handle is not a Direct3D device handle. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the method returns <strong>DXVA2_E_NEW_VIDEO_DEVICE</strong>, call <strong><see cref="SharpDX.MediaFoundation.DirectX.Direct3DDeviceManager.CloseDeviceHandle"/></strong> to close the handle and then call <strong>OpenDeviceHandle</strong> again to get a new handle. The <strong><see cref="SharpDX.MediaFoundation.DirectX.Direct3DDeviceManager.ResetDevice"/></strong> method invalidates all open device handles.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDeviceManager9::GetVideoService']/*"/>	
        /// <msdn-id>ms696198</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDeviceManager9::GetVideoService([In] void* hDevice,[In] const GUID&amp; riid,[Out] void** ppService)</unmanaged>	
        /// <unmanaged-short>IDirect3DDeviceManager9::GetVideoService</unmanaged-short>	
        public void GetVideoService(System.IntPtr hDevice, System.Guid riid, out System.IntPtr serviceOut) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* serviceOut_ = &serviceOut)
                    __result__= 
    				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)hDevice, (void*)&riid, serviceOut_,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Gets the range of values for an image filter that the Microsoft DirectX Video Acceleration High Definition (DXVA-HD) device supports. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To find out which image filters the device supports, check the <strong>FilterCaps</strong> member of the <strong><see cref="SharpDX.MediaFoundation.DirectX.Vpdevcaps"/></strong> structure. Call the <strong><see cref="SharpDX.MediaFoundation.DirectX.HDDevice.GetVideoProcessorDeviceCaps"/></strong> method to get this value.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDXVAHD_Device']/*"/>	
    /// <msdn-id>dd373915</msdn-id>	
    /// <unmanaged>IDXVAHD_Device</unmanaged>	
    /// <unmanaged-short>IDXVAHD_Device</unmanaged-short>	
    [Guid("95f12dfd-d77e-49be-815f-57d579634d6d")]
    public partial class HDDevice : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.DirectX.HDDevice"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public HDDevice(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.DirectX.HDDevice"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.MediaFoundation.DirectX.HDDevice(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.DirectX.HDDevice(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets the capabilities of the Microsoft DirectX Video Acceleration High Definition (DXVA-HD) device.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDXVAHD_Device::GetVideoProcessorDeviceCaps']/*"/>	
        /// <msdn-id>dd373914</msdn-id>	
        /// <unmanaged>GetVideoProcessorDeviceCaps</unmanaged>	
        /// <unmanaged-short>GetVideoProcessorDeviceCaps</unmanaged-short>	
        /// <unmanaged>HRESULT IDXVAHD_Device::GetVideoProcessorDeviceCaps([Out] DXVAHD_VPDEVCAPS* pCaps)</unmanaged>
        public SharpDX.MediaFoundation.DirectX.Vpdevcaps VideoProcessorDeviceCaps {
                get { SharpDX.MediaFoundation.DirectX.Vpdevcaps __output__; GetVideoProcessorDeviceCaps(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Creates one or more Microsoft Direct3D video surfaces.</p>	
        /// </summary>	
        /// <param name="width"><dd> <p>The width of each surface, in pixels.</p> </dd></param>	
        /// <param name="height"><dd> <p>The height of each surface, in pixels.</p> </dd></param>	
        /// <param name="format"><dd> <p>The pixel format, specified as a <strong><see cref="SharpDX.Direct3D9.Format"/></strong> value or FOURCC code. For more information, see Video FOURCCs.</p> </dd></param>	
        /// <param name="pool"><dd> <p>The memory pool in which the surface is  created. This parameter must equal the <strong>InputPool</strong> member of the <strong><see cref="SharpDX.MediaFoundation.DirectX.Vpdevcaps"/></strong> structure. Call the <strong><see cref="SharpDX.MediaFoundation.DirectX.HDDevice.GetVideoProcessorDeviceCaps"/></strong> method to get this value.</p> </dd></param>	
        /// <param name="usage"><dd> <p>Reserved. Set to 0.</p> </dd></param>	
        /// <param name="type"><dd> <p>The type of surface to create, specified as a member of the <strong><see cref="SharpDX.MediaFoundation.DirectX.SurfaceTypeHD"/></strong> enumeration.</p> </dd></param>	
        /// <param name="numSurfaces"><dd> <p>The number of surfaces to create.</p> </dd></param>	
        /// <param name="surfacesOut"><dd> <p>A reference to an array of <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> references. The <em>NumSurfaces</em> parameter specifies the number of elements in the array. The method fills the array with references to the new video surfaces. The caller must release the references.</p> </dd></param>	
        /// <param name="sharedHandleRef"><dd> <p>Reserved. Set to <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDXVAHD_Device::CreateVideoSurface']/*"/>	
        /// <msdn-id>dd373911</msdn-id>	
        /// <unmanaged>HRESULT IDXVAHD_Device::CreateVideoSurface([In] unsigned int Width,[In] unsigned int Height,[In] D3DFORMAT Format,[In] D3DPOOL Pool,[In] unsigned int Usage,[In] DXVAHD_SURFACE_TYPE Type,[In] unsigned int NumSurfaces,[Out, Buffer] IDirect3DSurface9** ppSurfaces,[InOut, Optional] void** pSharedHandle)</unmanaged>	
        /// <unmanaged-short>IDXVAHD_Device::CreateVideoSurface</unmanaged-short>	
        public void CreateVideoSurface(int width, int height, SharpDX.Direct3D9.Format format, SharpDX.Direct3D9.Pool pool, int usage, SharpDX.MediaFoundation.DirectX.SurfaceTypeHD type, int numSurfaces, SharpDX.Direct3D9.Surface[] surfacesOut, System.IntPtr sharedHandleRef) {
            unsafe {
                IntPtr* surfacesOut_ = stackalloc IntPtr[surfacesOut.Length];
                SharpDX.Result __result__;
                __result__= 
				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, width, height, unchecked((int)format), unchecked((int)pool), usage, unchecked((int)type), numSurfaces, surfacesOut_, (void*)sharedHandleRef,((void**)(*(void**)_nativePointer))[3]);		
                for (int i = 0; i < surfacesOut.Length; i++)
                    surfacesOut[i] = (surfacesOut_[i] == IntPtr.Zero)?null:new SharpDX.Direct3D9.Surface(surfacesOut_[i]);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the capabilities of the Microsoft DirectX Video Acceleration High Definition (DXVA-HD) device.</p>	
        /// </summary>	
        /// <param name="capsRef"><dd> <p>A reference to a <strong><see cref="SharpDX.MediaFoundation.DirectX.Vpdevcaps"/></strong> structure that receives the device capabilities.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDXVAHD_Device::GetVideoProcessorDeviceCaps']/*"/>	
        /// <msdn-id>dd373914</msdn-id>	
        /// <unmanaged>HRESULT IDXVAHD_Device::GetVideoProcessorDeviceCaps([Out] DXVAHD_VPDEVCAPS* pCaps)</unmanaged>	
        /// <unmanaged-short>IDXVAHD_Device::GetVideoProcessorDeviceCaps</unmanaged-short>	
        internal void GetVideoProcessorDeviceCaps(out SharpDX.MediaFoundation.DirectX.Vpdevcaps capsRef) {
            unsafe {
                capsRef = new SharpDX.MediaFoundation.DirectX.Vpdevcaps();
                SharpDX.Result __result__;
                fixed (void* capsRef_ = &capsRef)
                    __result__= 
    				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, capsRef_,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a list of the output formats supported by the Microsoft DirectX Video Acceleration High Definition (DXVA-HD) device.</p>	
        /// </summary>	
        /// <param name="count"><dd> <p>The number of formats to retrieve. This parameter must equal the <strong>OutputFormatCount</strong> member of the <strong><see cref="SharpDX.MediaFoundation.DirectX.Vpdevcaps"/></strong> structure. Call the <strong><see cref="SharpDX.MediaFoundation.DirectX.HDDevice.GetVideoProcessorDeviceCaps"/></strong> method to get this value.</p> </dd></param>	
        /// <param name="formatsRef"><dd> <p>A reference to an array of <strong><see cref="SharpDX.Direct3D9.Format"/></strong> values. The <em>Count</em> parameter specifies the number of elements in the array. The method fills the array with a list of output formats.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> The list of formats can include both <strong><see cref="SharpDX.Direct3D9.Format"/></strong> values, such as <strong><see cref="SharpDX.Direct3D9.Format.X8R8G8B8"/></strong>, and FOURCC codes, such as 'NV12'. For more information, see Video FOURCCs. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDXVAHD_Device::GetVideoProcessorOutputFormats']/*"/>	
        /// <msdn-id>dd373917</msdn-id>	
        /// <unmanaged>HRESULT IDXVAHD_Device::GetVideoProcessorOutputFormats([In] unsigned int Count,[Out, Buffer] D3DFORMAT* pFormats)</unmanaged>	
        /// <unmanaged-short>IDXVAHD_Device::GetVideoProcessorOutputFormats</unmanaged-short>	
        public void GetVideoProcessorOutputFormats(int count, SharpDX.Direct3D9.Format[] formatsRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* formatsRef_ = formatsRef)
                    __result__= 
    				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, count, formatsRef_,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a list of the input formats supported by the Microsoft DirectX Video Acceleration High Definition (DXVA-HD) device.</p>	
        /// </summary>	
        /// <param name="count"><dd> <p>The number of formats to retrieve. This parameter must equal the <strong>InputFormatCount</strong> member of the <strong><see cref="SharpDX.MediaFoundation.DirectX.Vpdevcaps"/></strong> structure. Call the <strong><see cref="SharpDX.MediaFoundation.DirectX.HDDevice.GetVideoProcessorDeviceCaps"/></strong> method to get this value.</p> </dd></param>	
        /// <param name="formatsRef"><dd> <p>A reference to an array of <strong><see cref="SharpDX.Direct3D9.Format"/></strong> values. The <em>Count</em> parameter specifies the number of elements in the array. The method fills the array with a list of input formats.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The list of formats can include both <strong><see cref="SharpDX.Direct3D9.Format"/></strong> values, such as <strong><see cref="SharpDX.Direct3D9.Format.X8R8G8B8"/></strong>, and FOURCC codes, such as 'NV12'. For more information, see Video FOURCCs.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDXVAHD_Device::GetVideoProcessorInputFormats']/*"/>	
        /// <msdn-id>dd373916</msdn-id>	
        /// <unmanaged>HRESULT IDXVAHD_Device::GetVideoProcessorInputFormats([In] unsigned int Count,[Out, Buffer] D3DFORMAT* pFormats)</unmanaged>	
        /// <unmanaged-short>IDXVAHD_Device::GetVideoProcessorInputFormats</unmanaged-short>	
        public void GetVideoProcessorInputFormats(int count, SharpDX.Direct3D9.Format[] formatsRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* formatsRef_ = formatsRef)
                    __result__= 
    				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, count, formatsRef_,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the capabilities of one or more Microsoft DirectX Video Acceleration High Definition (DXVA-HD) video processors.</p>	
        /// </summary>	
        /// <param name="count"><dd> <p>The number of elements in the <em>pCaps</em> array. This parameter must equal the <strong>VideoProcessorCount</strong> member of the <strong><see cref="SharpDX.MediaFoundation.DirectX.Vpdevcaps"/></strong> structure. Call the <strong><see cref="SharpDX.MediaFoundation.DirectX.HDDevice.GetVideoProcessorDeviceCaps"/></strong> method to get this value.</p> </dd></param>	
        /// <param name="capsRef"><dd> <p>A reference to an array of <strong><see cref="SharpDX.MediaFoundation.DirectX.Vpcaps"/></strong> structures. The method fills the structures with the capabilities of the video processors supported by the driver.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDXVAHD_Device::GetVideoProcessorCaps']/*"/>	
        /// <msdn-id>dd373912</msdn-id>	
        /// <unmanaged>HRESULT IDXVAHD_Device::GetVideoProcessorCaps([In] unsigned int Count,[Out, Buffer] DXVAHD_VPCAPS* pCaps)</unmanaged>	
        /// <unmanaged-short>IDXVAHD_Device::GetVideoProcessorCaps</unmanaged-short>	
        public void GetVideoProcessorCaps(int count, SharpDX.MediaFoundation.DirectX.Vpcaps[] capsRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* capsRef_ = capsRef)
                    __result__= 
    				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, count, capsRef_,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a list of custom rates that a Microsoft DirectX Video Acceleration High Definition (DXVA-HD) video processor supports. Custom rates are used for frame-rate conversion and inverse telecine (IVTC).</p>	
        /// </summary>	
        /// <param name="vPGuidRef"><dd> <p>A <see cref="System.Guid"/> that identifies the video processor to query. This <see cref="System.Guid"/> must equal the valud of the <strong>VPGuid</strong> member from one of the <strong><see cref="SharpDX.MediaFoundation.DirectX.Vpcaps"/></strong> structures retrieved by the <strong><see cref="SharpDX.MediaFoundation.DirectX.HDDevice.GetVideoProcessorCaps"/></strong> method.</p> </dd></param>	
        /// <param name="count"><dd> <p>The number of rates to retrieve. This parameter must equal the <strong>CustomRateCount</strong> member of the <strong><see cref="SharpDX.MediaFoundation.DirectX.Vpcaps"/></strong> structure for the video processor. </p> </dd></param>	
        /// <param name="ratesRef"><dd> <p>A reference to an array of <strong><see cref="SharpDX.MediaFoundation.DirectX.CustomRateData"/></strong> structures. The <em>Count</em> parameter specifies the number of elements in the array. The method fills the array with a list of custom rates.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDXVAHD_Device::GetVideoProcessorCustomRates']/*"/>	
        /// <msdn-id>dd373913</msdn-id>	
        /// <unmanaged>HRESULT IDXVAHD_Device::GetVideoProcessorCustomRates([In] const GUID* pVPGuid,[In] unsigned int Count,[Out, Buffer] DXVAHD_CUSTOM_RATE_DATA* pRates)</unmanaged>	
        /// <unmanaged-short>IDXVAHD_Device::GetVideoProcessorCustomRates</unmanaged-short>	
        public void GetVideoProcessorCustomRates(System.Guid vPGuidRef, int count, SharpDX.MediaFoundation.DirectX.CustomRateData[] ratesRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* ratesRef_ = ratesRef)
                    __result__= 
    				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)&vPGuidRef, count, ratesRef_,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the range of values for an image filter that the Microsoft DirectX Video Acceleration High Definition (DXVA-HD) device supports. </p>	
        /// </summary>	
        /// <param name="filter"><dd> <p>The type of image filter, specified as a member of the <strong><see cref="SharpDX.MediaFoundation.DirectX.Filter"/></strong> enumeration.</p> </dd></param>	
        /// <param name="rangeRef"><dd> <p>A reference to a <strong><see cref="SharpDX.MediaFoundation.DirectX.FilterRangeData"/></strong> structure. The method fills the structure with the range of values for the specified filter.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The <em>Filter</em> parameter is invalid or the device does not support the specified filter.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>To find out which image filters the device supports, check the <strong>FilterCaps</strong> member of the <strong><see cref="SharpDX.MediaFoundation.DirectX.Vpdevcaps"/></strong> structure. Call the <strong><see cref="SharpDX.MediaFoundation.DirectX.HDDevice.GetVideoProcessorDeviceCaps"/></strong> method to get this value.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDXVAHD_Device::GetVideoProcessorFilterRange']/*"/>	
        /// <msdn-id>dd373915</msdn-id>	
        /// <unmanaged>HRESULT IDXVAHD_Device::GetVideoProcessorFilterRange([In] DXVAHD_FILTER Filter,[Out] DXVAHD_FILTER_RANGE_DATA* pRange)</unmanaged>	
        /// <unmanaged-short>IDXVAHD_Device::GetVideoProcessorFilterRange</unmanaged-short>	
        public void GetVideoProcessorFilterRange(SharpDX.MediaFoundation.DirectX.Filter filter, out SharpDX.MediaFoundation.DirectX.FilterRangeData rangeRef) {
            unsafe {
                rangeRef = new SharpDX.MediaFoundation.DirectX.FilterRangeData();
                SharpDX.Result __result__;
                fixed (void* rangeRef_ = &rangeRef)
                    __result__= 
    				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)filter), rangeRef_,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a Microsoft DirectX Video Acceleration High Definition (DXVA-HD) video processor.</p>	
        /// </summary>	
        /// <param name="vPGuidRef"><dd> <p>A <see cref="System.Guid"/> that identifies the video processor to create. This <see cref="System.Guid"/> must equal the value of the <strong>VPGuid</strong> member from one of the <strong><see cref="SharpDX.MediaFoundation.DirectX.Vpcaps"/></strong> structures retrieved by the <strong><see cref="SharpDX.MediaFoundation.DirectX.HDDevice.GetVideoProcessorCaps"/></strong> method.</p> </dd></param>	
        /// <param name="videoProcessorOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.DirectX.HDVideoProcessor"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDXVAHD_Device::CreateVideoProcessor']/*"/>	
        /// <msdn-id>dd373910</msdn-id>	
        /// <unmanaged>HRESULT IDXVAHD_Device::CreateVideoProcessor([In] const GUID* pVPGuid,[Out] IDXVAHD_VideoProcessor** ppVideoProcessor)</unmanaged>	
        /// <unmanaged-short>IDXVAHD_Device::CreateVideoProcessor</unmanaged-short>	
        public void CreateVideoProcessor(System.Guid vPGuidRef, out SharpDX.MediaFoundation.DirectX.HDVideoProcessor videoProcessorOut) {
            unsafe {
                IntPtr videoProcessorOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &vPGuidRef, &videoProcessorOut_,((void**)(*(void**)_nativePointer))[10]);		
                videoProcessorOut= (videoProcessorOut_ == IntPtr.Zero)?null:new SharpDX.MediaFoundation.DirectX.HDVideoProcessor(videoProcessorOut_);	
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a Microsoft DirectX Video Acceleration High Definition (DXVA-HD) video processor. </p><p>To get a reference to this interface, call the <strong><see cref="SharpDX.MediaFoundation.DirectX.HDDevice.CreateVideoProcessor"/></strong> method.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDXVAHD_VideoProcessor']/*"/>	
    /// <msdn-id>dd373918</msdn-id>	
    /// <unmanaged>IDXVAHD_VideoProcessor</unmanaged>	
    /// <unmanaged-short>IDXVAHD_VideoProcessor</unmanaged-short>	
    [Guid("95f4edf4-6e03-4cd7-be1b-3075d665aa52")]
    public partial class HDVideoProcessor : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.DirectX.HDVideoProcessor"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public HDVideoProcessor(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.DirectX.HDVideoProcessor"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.MediaFoundation.DirectX.HDVideoProcessor(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.DirectX.HDVideoProcessor(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Sets a state parameter for a blit operation by a Microsoft DirectX Video Acceleration High Definition (DXVA-HD) device.</p>	
        /// </summary>	
        /// <param name="state"><dd> <p>The state parameter to set, specified as a member of the <strong><see cref="SharpDX.MediaFoundation.DirectX.BlitState"/></strong> enumeration.</p> </dd></param>	
        /// <param name="dataSize"><dd> <p>The size, in bytes, of the buffer pointed to by <em>pData</em>.</p> </dd></param>	
        /// <param name="dataRef"><dd> <p>A reference to a buffer that contains the state data. The meaning of the data depends on the <em>State</em> parameter. Each state has a corresponding data structure; for more information, see <strong><see cref="SharpDX.MediaFoundation.DirectX.BlitState"/></strong>. The caller allocates the buffer and fills in the parameter data before calling this method.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDXVAHD_VideoProcessor::SetVideoProcessBltState']/*"/>	
        /// <msdn-id>dd373921</msdn-id>	
        /// <unmanaged>HRESULT IDXVAHD_VideoProcessor::SetVideoProcessBltState([In] DXVAHD_BLT_STATE State,[In] unsigned int DataSize,[In, Buffer] const void* pData)</unmanaged>	
        /// <unmanaged-short>IDXVAHD_VideoProcessor::SetVideoProcessBltState</unmanaged-short>	
        public void SetVideoProcessBltState(SharpDX.MediaFoundation.DirectX.BlitState state, int dataSize, System.IntPtr dataRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)state), dataSize, (void*)dataRef,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the value of a state parameter for blit operations performed by a Microsoft DirectX Video Acceleration High Definition (DXVA-HD) device.</p>	
        /// </summary>	
        /// <param name="state"><dd> <p>The state parameter to query, specified as a member of the <strong><see cref="SharpDX.MediaFoundation.DirectX.BlitState"/></strong> enumeration.</p> </dd></param>	
        /// <param name="dataSize"><dd> <p>The size, in bytes, of the buffer pointed to by <em>pData</em>.</p> </dd></param>	
        /// <param name="dataRef"><dd> <p>A reference to a buffer allocated by the caller. The method copies the state data into the buffer. The buffer must be large enough to hold the data structure that corresponds to the state parameter. For more information, see <strong><see cref="SharpDX.MediaFoundation.DirectX.BlitState"/></strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDXVAHD_VideoProcessor::GetVideoProcessBltState']/*"/>	
        /// <msdn-id>dd373919</msdn-id>	
        /// <unmanaged>HRESULT IDXVAHD_VideoProcessor::GetVideoProcessBltState([In] DXVAHD_BLT_STATE State,[In] unsigned int DataSize,[Out, Buffer] void* pData)</unmanaged>	
        /// <unmanaged-short>IDXVAHD_VideoProcessor::GetVideoProcessBltState</unmanaged-short>	
        public void GetVideoProcessBltState(SharpDX.MediaFoundation.DirectX.BlitState state, int dataSize, System.IntPtr dataRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)state), dataSize, (void*)dataRef,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a state parameter for an input stream on a  Microsoft DirectX Video Acceleration High Definition (DXVA-HD) device.</p>	
        /// </summary>	
        /// <param name="streamNumber"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong><see cref="SharpDX.MediaFoundation.DirectX.HDDevice.GetVideoProcessorDeviceCaps"/></strong> and check the <strong>MaxStreamStates</strong> member of the <strong><see cref="SharpDX.MediaFoundation.DirectX.Vpdevcaps"/></strong> structure.</p> </dd></param>	
        /// <param name="state"><dd> <p>The state parameter to set, specified as a member of the <strong><see cref="SharpDX.MediaFoundation.DirectX.StreamState"/></strong> enumeration.</p> </dd></param>	
        /// <param name="dataSize"><dd> <p>The size, in bytes, of the buffer pointed to by <em>pData</em>.</p> </dd></param>	
        /// <param name="dataRef"><dd> <p>A reference to a buffer that contains the state data. The meaning of the data depends on the <em>State</em> parameter. Each state has a corresponding data structure; for more information, see <strong><see cref="SharpDX.MediaFoundation.DirectX.StreamState"/></strong>. The caller allocates the buffer and fills in the parameter data before calling this method.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> Call this method to set state parameters that apply to individual input streams.  </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDXVAHD_VideoProcessor::SetVideoProcessStreamState']/*"/>	
        /// <msdn-id>dd373922</msdn-id>	
        /// <unmanaged>HRESULT IDXVAHD_VideoProcessor::SetVideoProcessStreamState([In] unsigned int StreamNumber,[In] DXVAHD_STREAM_STATE State,[In] unsigned int DataSize,[In, Buffer] const void* pData)</unmanaged>	
        /// <unmanaged-short>IDXVAHD_VideoProcessor::SetVideoProcessStreamState</unmanaged-short>	
        public void SetVideoProcessStreamState(int streamNumber, SharpDX.MediaFoundation.DirectX.StreamState state, int dataSize, System.IntPtr dataRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, streamNumber, unchecked((int)state), dataSize, (void*)dataRef,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the value of a state parameter for an input stream on a  Microsoft DirectX Video Acceleration High Definition (DXVA-HD) device.</p>	
        /// </summary>	
        /// <param name="streamNumber"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong><see cref="SharpDX.MediaFoundation.DirectX.HDDevice.GetVideoProcessorDeviceCaps"/></strong> and check the <strong>MaxStreamStates</strong> member of the <strong><see cref="SharpDX.MediaFoundation.DirectX.Vpdevcaps"/></strong> structure.</p> </dd></param>	
        /// <param name="state"><dd> <p>The state parameter to query, specified as a member of the <strong><see cref="SharpDX.MediaFoundation.DirectX.StreamState"/></strong> enumeration.</p> </dd></param>	
        /// <param name="dataSize"><dd> <p>The size, in bytes, of the buffer pointed to by <em>pData</em>.</p> </dd></param>	
        /// <param name="dataRef"><dd> <p>A reference to a buffer allocated by the caller. The method copies the state data into the buffer. The buffer must be large enough to hold the data structure that corresponds to the state parameter. For more information, see <strong><see cref="SharpDX.MediaFoundation.DirectX.StreamState"/></strong>. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDXVAHD_VideoProcessor::GetVideoProcessStreamState']/*"/>	
        /// <msdn-id>dd373920</msdn-id>	
        /// <unmanaged>HRESULT IDXVAHD_VideoProcessor::GetVideoProcessStreamState([In] unsigned int StreamNumber,[In] DXVAHD_STREAM_STATE State,[In] unsigned int DataSize,[Out, Buffer] void* pData)</unmanaged>	
        /// <unmanaged-short>IDXVAHD_VideoProcessor::GetVideoProcessStreamState</unmanaged-short>	
        public void GetVideoProcessStreamState(int streamNumber, SharpDX.MediaFoundation.DirectX.StreamState state, int dataSize, System.IntPtr dataRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, streamNumber, unchecked((int)state), dataSize, (void*)dataRef,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Performs a video processing blit on one or more input samples and writes the result to a Microsoft Direct3D surface.</p>	
        /// </summary>	
        /// <param name="outputSurfaceRef"><dd> <p>A reference to the <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface of a Direct3D surface. The output of the video processing operation will be written to this surface. The following surface types can be used:</p> <ul> <li>A video surface of type <strong><see cref="SharpDX.MediaFoundation.DirectX.SurfaceTypeHD.VideoOutput"/></strong>. See <strong><see cref="SharpDX.MediaFoundation.DirectX.HDDevice.CreateVideoSurface"/></strong>. </li> <li>A render-target surface or texture surface created with <see cref="SharpDX.Direct3D9.Usage.RenderTarget"/> usage.</li> <li>A swap chain.</li> <li>A swap chain with overlay support (<strong><see cref="SharpDX.Direct3D9.SwapEffect.Overlay"/></strong>).</li> </ul> </dd></param>	
        /// <param name="outputFrame"><dd> <p>Frame number of the output video frame, indexed from zero.</p> </dd></param>	
        /// <param name="streamCount"><dd> <p>Number of input streams to process. </p> </dd></param>	
        /// <param name="streamsRef"><dd> <p>Pointer to an array of <strong><see cref="SharpDX.MediaFoundation.DirectX.StreamData"/></strong> structures that contain information about the input streams. The caller allocates the array and fills in each structure. The number of elements in the array is given in the <em>StreamCount</em> parameter.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The maximum value of <em>StreamCount</em> is given in the <strong>MaxStreamStates</strong> member of the <strong><see cref="SharpDX.MediaFoundation.DirectX.Vpdevcaps"/></strong> structure. The maximum numbr of streams that can be enabled at one time is given in the <strong>MaxInputStreams</strong> member of that structure.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDXVAHD_VideoProcessor::VideoProcessBltHD']/*"/>	
        /// <msdn-id>dd373923</msdn-id>	
        /// <unmanaged>HRESULT IDXVAHD_VideoProcessor::VideoProcessBltHD([In] IDirect3DSurface9* pOutputSurface,[In] unsigned int OutputFrame,[In] unsigned int StreamCount,[In, Buffer] const DXVAHD_STREAM_DATA* pStreams)</unmanaged>	
        /// <unmanaged-short>IDXVAHD_VideoProcessor::VideoProcessBltHD</unmanaged-short>	
        public void VideoProcessBltHD(SharpDX.Direct3D9.Surface outputSurfaceRef, int outputFrame, int streamCount, SharpDX.MediaFoundation.DirectX.StreamData[] streamsRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* streamsRef_ = streamsRef)
                    __result__= 
    				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((outputSurfaceRef == null)?IntPtr.Zero:outputSurfaceRef.NativePointer), outputFrame, streamCount, streamsRef_,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides DirectX Video Acceleration (DXVA) services from a Direct3D device. To get a reference to this interface, call <strong><see cref="SharpDX.MediaFoundation.DirectX.Direct3DDeviceManager.GetVideoService"/></strong> or <strong><see cref="SharpDX.MediaFoundation.DirectX.DXVAFactory.CreateVideoService"/></strong>.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This is the base interface for DXVA services. The Direct3D device can support any of the following DXVA services, which derive from <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoAccelerationService"/></strong>:</p><ul> <li> Video decoding: <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDecoderService"/></strong> </li> <li> Video processing: <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoProcessorService"/></strong> </li> </ul>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoAccelerationService']/*"/>	
    /// <msdn-id>ms697049</msdn-id>	
    /// <unmanaged>IDirectXVideoAccelerationService</unmanaged>	
    /// <unmanaged-short>IDirectXVideoAccelerationService</unmanaged-short>	
    [Guid("fc51a550-d5e7-11d9-af55-00054e43ff02")]
    public partial class VideoAccelerationService : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.DirectX.VideoAccelerationService"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VideoAccelerationService(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.DirectX.VideoAccelerationService"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.MediaFoundation.DirectX.VideoAccelerationService(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.DirectX.VideoAccelerationService(nativePointer);
		}
        
        
        /// <summary>	
        /// <p> Creates a DirectX Video Acceleration (DXVA) video processor or DXVA decoder render target. </p>	
        /// </summary>	
        /// <param name="width"><dd> <p>The width of the surface, in pixels. </p> </dd></param>	
        /// <param name="height"><dd> <p>The height of the surface, in pixels. </p> </dd></param>	
        /// <param name="backBuffers"><dd> <p>The number of back buffers. The method creates <em>BackBuffers</em> + 1 surfaces. </p> </dd></param>	
        /// <param name="format"><dd> <p>The pixel format, specified as a <strong><see cref="SharpDX.Direct3D9.Format"/></strong> value or FOURCC code. For more information, see the Direct3D documentation. </p> </dd></param>	
        /// <param name="pool"><dd> <p>The memory pool in which to create the surface, specified as a <strong><see cref="SharpDX.Direct3D9.Pool"/></strong> value. For more information, see the Direct3D documentation. Decoders should generally use the value <see cref="SharpDX.Direct3D9.Pool.Default"/>. </p> </dd></param>	
        /// <param name="usage"><dd> <p>Reserved. Set this value to zero. </p> </dd></param>	
        /// <param name="dxvaType"><dd> <p>The type of surface to create. Use one of the following values. </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.MediaFoundation.DirectX.RenderTargetType.VideoDecoder"/></strong></dt> </dl> </td><td> <p>Video decoder render target. </p> </td></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.MediaFoundation.DirectX.RenderTargetType.VideoProcessor"/></strong></dt> </dl> </td><td> <p>Video processor render target. Used for <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoProcessor.VideoProcessBlt"/></strong> operations. </p> </td></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.MediaFoundation.DirectX.RenderTargetType.VideoSoftware"/></strong></dt> </dl> </td><td> <p>Software render target. This surface type is for use with software DXVA devices. </p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="surfaceOut"><dd> <p>The address of an array of <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> references allocated by the caller. The size of the array must be 1 + <em>BackBuffers</em> (enough for the back buffers plus one front buffer). The method fills the array with <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> references. The caller must release all of the interface references. In addition, the front buffer holds a reference count on each of the back buffers. Therefore, the back buffers are never deleted until the front buffer is deleted. </p> </dd></param>	
        /// <param name="sharedHandleRef"><dd> <p>A reference to a handle that is used to share the surfaces between Direct3D devices. Set this parameter to <strong><c>null</c></strong>. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/></strong></dt> </dl> </td><td> <p> Invalid parameter </p> </td></tr> <tr><td> <dl> <dt><strong>E_FAIL</strong></dt> </dl> </td><td> <p> The DirectX Video Acceleration Manager is not initialized. </p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p><strong><c>null</c></strong> reference argument. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the method returns <strong>E_FAIL</strong>, try calling <strong><see cref="SharpDX.MediaFoundation.DirectX.Direct3DDeviceManager.ResetDevice"/></strong> to reset the DirectX Video Acceleration Manager.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoAccelerationService::CreateSurface']/*"/>	
        /// <msdn-id>ms696227</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoAccelerationService::CreateSurface([In] unsigned int Width,[In] unsigned int Height,[In] unsigned int BackBuffers,[In] D3DFORMAT Format,[In] D3DPOOL Pool,[In] unsigned int Usage,[In] unsigned int DxvaType,[Out, Buffer] IDirect3DSurface9** ppSurface,[InOut, Optional] void** pSharedHandle)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoAccelerationService::CreateSurface</unmanaged-short>	
        public bool CreateSurface(int width, int height, int backBuffers, SharpDX.Direct3D9.Format format, SharpDX.Direct3D9.Pool pool, int usage, int dxvaType, SharpDX.Direct3D9.Surface[] surfaceOut, System.IntPtr sharedHandleRef) {
            unsafe {
                IntPtr* surfaceOut_ = stackalloc IntPtr[surfaceOut.Length];
                SharpDX.Result __result__;
                __result__= 
				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, width, height, backBuffers, unchecked((int)format), unchecked((int)pool), usage, dxvaType, surfaceOut_, (void*)sharedHandleRef,((void**)(*(void**)_nativePointer))[3]);		
                for (int i = 0; i < surfaceOut.Length; i++)
                    surfaceOut[i] = (surfaceOut_[i] == IntPtr.Zero)?null:new SharpDX.Direct3D9.Surface(surfaceOut_[i]);
                return __result__.Success;
            }
        }
    }
    /// <summary>	
    /// <p> Represents a DirectX Video Acceleration (DXVA) video decoder device.</p><p> To get a reference to this interface, call <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDecoderService.CreateVideoDecoder"/></strong>. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDecoder"/></strong> methods make calls to the Direct3D device. Therefore, the <strong><see cref="SharpDX.Direct3D9.CreateFlags"/></strong> flags that you specify  when creating the device can affect the behavior of this interface. For example, if you specify the <strong><see cref="SharpDX.Direct3D9.CreateFlags.Multithreaded"/></strong> flag, the Direct3D global critical section will be held during decode operations.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoDecoder']/*"/>	
    /// <msdn-id>ms694281</msdn-id>	
    /// <unmanaged>IDirectXVideoDecoder</unmanaged>	
    /// <unmanaged-short>IDirectXVideoDecoder</unmanaged-short>	
    [Guid("f2b0810a-fd00-43c9-918c-df94e2d8ef7d")]
    public partial class VideoDecoder : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.DirectX.VideoDecoder"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VideoDecoder(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.DirectX.VideoDecoder"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.MediaFoundation.DirectX.VideoDecoder(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.DirectX.VideoDecoder(nativePointer);
		}
        
        
        /// <summary>	
        /// <p> Retrieves the DirectX Video Acceleration (DXVA) decoder service that created this decoder device. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoDecoder::GetVideoDecoderService']/*"/>	
        /// <msdn-id>ms694049</msdn-id>	
        /// <unmanaged>GetVideoDecoderService</unmanaged>	
        /// <unmanaged-short>GetVideoDecoderService</unmanaged-short>	
        /// <unmanaged>HRESULT IDirectXVideoDecoder::GetVideoDecoderService([Out] IDirectXVideoDecoderService** ppService)</unmanaged>
        public SharpDX.MediaFoundation.DirectX.VideoDecoderService VideoDecoderService {
                get { SharpDX.MediaFoundation.DirectX.VideoDecoderService __output__; GetVideoDecoderService(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p> Retrieves the DirectX Video Acceleration (DXVA) decoder service that created this decoder device. </p>	
        /// </summary>	
        /// <param name="serviceOut"><dd> <p>Receives a reference to <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDecoderService"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoDecoder::GetVideoDecoderService']/*"/>	
        /// <msdn-id>ms694049</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoDecoder::GetVideoDecoderService([Out] IDirectXVideoDecoderService** ppService)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoDecoder::GetVideoDecoderService</unmanaged-short>	
        internal void GetVideoDecoderService(out SharpDX.MediaFoundation.DirectX.VideoDecoderService serviceOut) {
            unsafe {
                IntPtr serviceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &serviceOut_,((void**)(*(void**)_nativePointer))[3]);		
                serviceOut= (serviceOut_ == IntPtr.Zero)?null:new SharpDX.MediaFoundation.DirectX.VideoDecoderService(serviceOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Retrieves the parameters that were used to create this device. </p>	
        /// </summary>	
        /// <param name="deviceGuidRef"><dd> <p>Receives the device <see cref="System.Guid"/>. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="videoDescRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDesc"/></strong> structure that receives a description of the video format. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="configRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.MediaFoundation.DirectX.ConfigPictureDecode"/></strong> structure structure that receives the decoder configuration. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="decoderRenderTargetsRef"><dd> <p>Receives an array of <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface references. These references represent the decoder render targets. The method allocates the memory for the array and calls <strong>AddRef</strong> on each of the references. The caller must release the references and call <strong>CoTaskMemFree</strong> to free the memory for the array. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="numSurfacesRef"><dd> <p>Receives the number of elements in the <em>pppDecoderRenderTargets</em> array. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument. At least one parameter must be non-<strong><c>null</c></strong>.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>You can set any parameter to <strong><c>null</c></strong> if you are not interested in the result. At least one parameter must be non-<strong><c>null</c></strong>.</p><p>If you specify a non-<strong><c>null</c></strong> value for <em>pppDecoderRenderTargets</em> (to receive the render target surfaces), then <em>pNumSurfaces</em> cannot be <strong><c>null</c></strong>, because it receives the size of the array returned in <em>pppDecoderRenderTargets</em>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoDecoder::GetCreationParameters']/*"/>	
        /// <msdn-id>ms697355</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoDecoder::GetCreationParameters([Out, Optional] GUID* pDeviceGuid,[Out, Optional] DXVA2_VideoDesc* pVideoDesc,[Out, Optional] DXVA2_ConfigPictureDecode* pConfig,[Out, Buffer] IDirect3DSurface9*** pDecoderRenderTargets,[Out, Optional] unsigned int* pNumSurfaces)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoDecoder::GetCreationParameters</unmanaged-short>	
        public void GetCreationParameters(out System.Guid deviceGuidRef, out SharpDX.MediaFoundation.DirectX.VideoDesc videoDescRef, out SharpDX.MediaFoundation.DirectX.ConfigPictureDecode configRef, SharpDX.Direct3D9.Surface[] decoderRenderTargetsRef, out int numSurfacesRef) {
            unsafe {
                deviceGuidRef = new System.Guid();
                videoDescRef = new SharpDX.MediaFoundation.DirectX.VideoDesc();
                configRef = new SharpDX.MediaFoundation.DirectX.ConfigPictureDecode();
                IntPtr* decoderRenderTargetsRef_ = stackalloc IntPtr[decoderRenderTargetsRef.Length];
                SharpDX.Result __result__;
                fixed (void* deviceGuidRef_ = &deviceGuidRef)
                    fixed (void* videoDescRef_ = &videoDescRef)
                        fixed (void* configRef_ = &configRef)
                            fixed (void* numSurfacesRef_ = &numSurfacesRef)
                                __result__= 
                				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, deviceGuidRef_, videoDescRef_, configRef_, (void*)decoderRenderTargetsRef_, numSurfacesRef_,((void**)(*(void**)_nativePointer))[4]);		
                for (int i = 0; i < decoderRenderTargetsRef.Length; i++)
                    decoderRenderTargetsRef[i] = (decoderRenderTargetsRef_[i] == IntPtr.Zero)?null:new SharpDX.Direct3D9.Surface(decoderRenderTargetsRef_[i]);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Retrieves a reference to a DirectX Video Acceleration (DXVA) decoder buffer. </p>	
        /// </summary>	
        /// <param name="bufferType"><dd> <p>Type of buffer to retrieve. Use one of the following values.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.MediaFoundation.DirectX.CompressedBufferType.PictureParameters"/></strong></dt> </dl> </td><td> <p>Picture decoding parameter buffer.</p> </td></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.MediaFoundation.DirectX.CompressedBufferType.MacroBlockControl"/></strong></dt> </dl> </td><td> <p>Macroblock control command buffer.</p> </td></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.MediaFoundation.DirectX.CompressedBufferType.ResidualDifference"/></strong></dt> </dl> </td><td> <p>Residual difference block data buffer.</p> </td></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.MediaFoundation.DirectX.CompressedBufferType.DeblockingControl"/></strong></dt> </dl> </td><td> <p>Deblocking filter control command buffer.</p> </td></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.MediaFoundation.DirectX.CompressedBufferType.InverseQuantizationMatrix"/></strong></dt> </dl> </td><td> <p>Inverse quantization matrix buffer.</p> </td></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.MediaFoundation.DirectX.CompressedBufferType.SliceControl"/></strong></dt> </dl> </td><td> <p>Slice-control buffer.</p> </td></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.MediaFoundation.DirectX.CompressedBufferType.BitStreamDate"/></strong></dt> </dl> </td><td> <p>Bitstream data buffer.</p> </td></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.MediaFoundation.DirectX.CompressedBufferType.Dxva2MotionVectorBuffer"/></strong></dt> </dl> </td><td> <p>Motion vector buffer.</p> </td></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.MediaFoundation.DirectX.CompressedBufferType.Dxva2FilmGrainBuffer"/></strong></dt> </dl> </td><td> <p>Film grain synthesis data buffer.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="bufferOut"><dd> <p>Receives a reference to the start of the memory buffer.</p> </dd></param>	
        /// <param name="bufferSizeRef"><dd> <p>Receives the size of the buffer, in bytes.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The method locks the Direct3D surface that contains the buffer. When you are done using the buffer, call <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDecoder.ReleaseBuffer"/></strong> to unlock the surface.</p><p>This method might block if too many operations have been queued on the GPU. The method unblocks when a free buffer becomes available.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoDecoder::GetBuffer']/*"/>	
        /// <msdn-id>ms703992</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoDecoder::GetBuffer([In] unsigned int BufferType,[Out] void** ppBuffer,[Out] unsigned int* pBufferSize)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoDecoder::GetBuffer</unmanaged-short>	
        public void GetBuffer(int bufferType, out System.IntPtr bufferOut, out int bufferSizeRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* bufferOut_ = &bufferOut)
                    fixed (void* bufferSizeRef_ = &bufferSizeRef)
                        __result__= 
        				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, bufferType, bufferOut_, bufferSizeRef_,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Releases a buffer that was obtained by calling <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDecoder.GetBuffer"/></strong>. </p>	
        /// </summary>	
        /// <param name="bufferType">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoDecoder::ReleaseBuffer']/*"/>	
        /// <msdn-id>ms704764</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoDecoder::ReleaseBuffer([In] unsigned int BufferType)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoDecoder::ReleaseBuffer</unmanaged-short>	
        public void ReleaseBuffer(int bufferType) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, bufferType,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Starts the decoding operation. </p>	
        /// </summary>	
        /// <param name="renderTargetRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface of the render target where the decoded frame will be written.</p> </dd></param>	
        /// <param name="vPVPDataRef"><dd> <p>Reserved; set to <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid surface type. See Remarks.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>After this method is called, call <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDecoder.Execute"/></strong> to perform decoding operations. When all decoding operations have been executed, call <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDecoder.EndFrame"/></strong>.</p><p>Each call to <strong>BeginFrame</strong> must have a matching call to <strong>EndFrame</strong>, and <strong>BeginFrame</strong> calls cannot be nested.</p><p>DXVA 1.0 migration note: Unlike the <strong>IAMVideoAccelerator::BeginFrame</strong> method, which specifies the buffer as an index, this method takes a reference directly to the uncompressed buffer.</p><p>The surface pointed to by <em>pRenderTarget</em> must be created by calling <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoAccelerationService.CreateSurface"/></strong> with the value <see cref="SharpDX.MediaFoundation.DirectX.RenderTargetType.VideoDecoder"/> for <em>DxvaType</em>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoDecoder::BeginFrame']/*"/>	
        /// <msdn-id>ms694840</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoDecoder::BeginFrame([In] IDirect3DSurface9* pRenderTarget,[In, Optional] void* pvPVPData)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoDecoder::BeginFrame</unmanaged-short>	
        public void BeginFrame(SharpDX.Direct3D9.Surface renderTargetRef, System.IntPtr vPVPDataRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((renderTargetRef == null)?IntPtr.Zero:renderTargetRef.NativePointer), (void*)vPVPDataRef,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Signals the end of the decoding operation. </p>	
        /// </summary>	
        /// <param name="handleCompleteRef"><dd> <p>Reserved.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoDecoder::EndFrame']/*"/>	
        /// <msdn-id>ms697031</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoDecoder::EndFrame([InOut, Optional] void** pHandleComplete)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoDecoder::EndFrame</unmanaged-short>	
        public void EndFrame(System.IntPtr handleCompleteRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)handleCompleteRef,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Executes a decoding operation on the current frame. </p>	
        /// </summary>	
        /// <param name="executeParamsRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.MediaFoundation.DirectX.DecodeExecuteParams"/></strong> structure that contains the information needed for the decoding operation.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>You must call <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDecoder.BeginFrame"/></strong> before calling this method.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoDecoder::Execute']/*"/>	
        /// <msdn-id>ms696258</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoDecoder::Execute([In] const DXVA2_DecodeExecuteParams* pExecuteParams)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoDecoder::Execute</unmanaged-short>	
        public void Execute(SharpDX.MediaFoundation.DirectX.DecodeExecuteParams executeParamsRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &executeParamsRef,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides access to DirectX Video Acceleration (DXVA) decoder services. Use this interface to query which hardware-accelerated decoding operations are available and to create DXVA video decoder devices. </p><p>To get a reference to this interface, call <strong><see cref="SharpDX.MediaFoundation.DirectX.Direct3DDeviceManager.GetVideoService"/></strong> or <strong><see cref="SharpDX.MediaFoundation.DirectX.DXVAFactory.CreateVideoService"/></strong> with the interface identifier IID_IDirectXVideoDecoderService.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoDecoderService']/*"/>	
    /// <msdn-id>ms704820</msdn-id>	
    /// <unmanaged>IDirectXVideoDecoderService</unmanaged>	
    /// <unmanaged-short>IDirectXVideoDecoderService</unmanaged-short>	
    [Guid("fc51a551-d5e7-11d9-af55-00054e43ff02")]
    public partial class VideoDecoderService : SharpDX.MediaFoundation.DirectX.VideoAccelerationService {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.DirectX.VideoDecoderService"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VideoDecoderService(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.DirectX.VideoDecoderService"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.MediaFoundation.DirectX.VideoDecoderService(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.DirectX.VideoDecoderService(nativePointer);
		}
        
        
        /// <summary>	
        /// <p> </p><p>Retrieves an array of GUIDs that identifies the decoder devices supported by the graphics hardware.</p>	
        /// </summary>	
        /// <param name="countRef"><dd> <p>Receives the number of GUIDs.</p> </dd></param>	
        /// <param name="guidsRef"><dd> <p>Receives an array of GUIDs. The size of the array is retrieved in the <em>Count</em> parameter. The method allocates the memory for the array. The caller must free the memory by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/></strong></dt> </dl> </td><td> <p>Error from the Direct3D device.</p> </td></tr> <tr><td> <dl> <dt><strong>E_FAIL</strong></dt> </dl> </td><td> <p>If the Microsoft Basic Display Adapter is being used or the Direct3D?11 device type is the reference rasterizer.  These devices do not support video decoders.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The following decoder GUIDs are defined. Some of these GUIDs have alternate names, shown in parentheses.</p><table> <tr><th><see cref="System.Guid"/></th><th>Description</th></tr> <tr><td>DXVA2_ModeH264_A (DXVA2_ModeH264_MoComp_NoFGT)</td><td>H.264 motion compensation (MoComp), no film grain technology (FGT).</td></tr> <tr><td>DXVA2_ModeH264_B (DXVA2_ModeH264_MoComp_FGT)</td><td>H.264 MoComp, FGT.</td></tr> <tr><td>DXVA2_ModeH264_C (DXVA2_ModeH264_IDCT_NoFGT)</td><td>H.264 inverse discrete cosine transform (IDCT), no FGT.</td></tr> <tr><td>DXVA2_ModeH264_D (DXVA2_ModeH264_IDCT_FGT)</td><td>H.264 IDCT, FGT.</td></tr> <tr><td>DXVA2_ModeH264_E (DXVA2_ModeH264_VLD_NoFGT)</td><td>H.264 VLD, no FGT.</td></tr> <tr><td>DXVA2_ModeH264_F (DXVA2_ModeH264_VLD_FGT)</td><td>H.264 variable-length decoder (VLD), FGT.</td></tr> <tr><td>DXVA2_ModeMPEG2_IDCT</td><td>MPEG-2 IDCT.</td></tr> <tr><td>DXVA2_ModeMPEG2_MoComp</td><td>MPEG-2 MoComp.</td></tr> <tr><td>DXVA2_ModeMPEG2_VLD</td><td>MPEG-2 VLD.</td></tr> <tr><td>DXVA2_ModeVC1_A (DXVA2_ModeVC1_PostProc)</td><td>VC-1 post processing.</td></tr> <tr><td>DXVA2_ModeVC1_B (DXVA2_ModeVC1_MoComp)</td><td>VC-1 MoComp.</td></tr> <tr><td>DXVA2_ModeVC1_C (DXVA2_ModeVC1_IDCT)</td><td>VC-1 IDCT.</td></tr> <tr><td>DXVA2_ModeVC1_D (DXVA2_ModeVC1_VLD)</td><td>VC-1 VLD.</td></tr> <tr><td>DXVA2_ModeWMV8_A (DXVA2_ModeWMV8_PostProc)</td><td>Windows Media Video 8 post processing.</td></tr> <tr><td>DXVA2_ModeWMV8_B (DXVA2_ModeWMV8_MoComp)</td><td>Windows Media Video 8 MoComp.</td></tr> <tr><td>DXVA2_ModeWMV9_A (DXVA2_ModeWMV9_PostProc)</td><td>Windows Media Video 9 post processing.</td></tr> <tr><td>DXVA2_ModeWMV9_B (DXVA2_ModeWMV9_MoComp)</td><td>Windows Media Video 9 MoComp.</td></tr> <tr><td>DXVA2_ModeWMV9_C (DXVA2_ModeWMV9_IDCT)</td><td>Windows Media Video 9 IDCT.</td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoDecoderService::GetDecoderDeviceGuids']/*"/>	
        /// <msdn-id>ms697067</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoDecoderService::GetDecoderDeviceGuids([Out] unsigned int* pCount,[Out, Buffer, Optional] GUID** pGuids)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoDecoderService::GetDecoderDeviceGuids</unmanaged-short>	
        public unsafe void GetDecoderDeviceGuids(out int countRef, System.Guid[] guidsRef) {
            SharpDX.Result __result__;
            IntPtr guidArr_ = IntPtr.Zero;

            fixed (void* countRef_ = &countRef)
            {
                __result__ = 
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, countRef_, &guidArr_,((void**)(*(void**)_nativePointer))[4]);
            }

            __result__.CheckError();

            for (int i = 0; i < countRef && i < guidsRef.Length; i++)
            {
                IntPtr ins = guidArr_ + i * Marshal.SizeOf(typeof(Guid));
                guidsRef[i] = (Guid)Marshal.PtrToStructure(ins, typeof(Guid));
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the supported render targets for a specified decoder device.</p>	
        /// </summary>	
        /// <param name="guid"><dd> <p><see cref="System.Guid"/> that identifies the decoder device. To get the available device GUIDs, call <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDecoderService.GetDecoderDeviceGuids"/></strong>.</p> </dd></param>	
        /// <param name="countRef"><dd> <p>Receives the number of formats.</p> </dd></param>	
        /// <param name="formatsRef"><dd> <p>Receives an array of formats, specified as <strong><see cref="SharpDX.Direct3D9.Format"/></strong> values. The size of the array is retrieved in the <em>pCount</em> parameter. The method allocates the memory for the array. The caller must free the memory by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoDecoderService::GetDecoderRenderTargets']/*"/>	
        /// <msdn-id>ms703193</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoDecoderService::GetDecoderRenderTargets([In] const GUID&amp; Guid,[Out] unsigned int* pCount,[Out, Buffer, Optional] D3DFORMAT** pFormats)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoDecoderService::GetDecoderRenderTargets</unmanaged-short>	
        public unsafe void GetDecoderRenderTargets(System.Guid guid, out int countRef, SharpDX.Direct3D9.Format[] formatsRef) {

            IntPtr formatsRef_ = IntPtr.Zero;
            SharpDX.Result __result__;

            fixed (void* countRef_ = &countRef)
            {
                __result__ = 
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guid, countRef_, &formatsRef_,((void**)(*(void**)_nativePointer))[5]);
            }

            __result__.CheckError();

            for (int i = 0; i < countRef && i < formatsRef.Length; i++)
            {
                IntPtr ins = formatsRef_ + i * Marshal.SizeOf(typeof(int));
                formatsRef[i] = (SharpDX.Direct3D9.Format)Marshal.ReadInt32(ins);
            }
        }

        /// <summary>	
        /// <p>Gets the configurations that are available for a decoder device. </p>	
        /// </summary>	
        /// <param name="guid"><dd> <p>A <see cref="System.Guid"/> that identifies the decoder device. To get the available device GUIDs, call <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDecoderService.GetDecoderDeviceGuids"/></strong>. </p> </dd></param>	
        /// <param name="videoDescRef"><dd> <p>A reference to a <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDesc"/></strong> structure that describes the video content. </p> </dd></param>	
        /// <param name="reservedRef"><dd> <p>Reserved. Set to <strong><c>null</c></strong>. </p> </dd></param>	
        /// <param name="countRef"><dd> <p>Receives the number of configurations. </p> </dd></param>	
        /// <param name="configsOut"><dd> <p>Receives an array of <strong><see cref="SharpDX.MediaFoundation.DirectX.ConfigPictureDecode"/></strong> structures. The size of the array is retrieved in the <em>pCount</em> parameter. The caller must free the memory for the array by calling <strong>CoTaskMemFree</strong>. This parameter can be <strong><c>null</c></strong> if you simply want the number of configurations (returned in <em>pCount</em>) but not the GUIDs. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoDecoderService::GetDecoderConfigurations']/*"/>	
        /// <msdn-id>ms699833</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoDecoderService::GetDecoderConfigurations([In] const GUID&amp; Guid,[In] const DXVA2_VideoDesc* pVideoDesc,[In] void* pReserved,[Out] unsigned int* pCount,[Out, Buffer, Optional] DXVA2_ConfigPictureDecode** ppConfigs)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoDecoderService::GetDecoderConfigurations</unmanaged-short>	
        public unsafe bool GetDecoderConfigurations(System.Guid guid, ref SharpDX.MediaFoundation.DirectX.VideoDesc videoDescRef, System.IntPtr reservedRef, out int countRef, SharpDX.MediaFoundation.DirectX.ConfigPictureDecode[] configsOut)
        {
            IntPtr configsOut_ = IntPtr.Zero;

            SharpDX.Result __result__;
            fixed (void* videoDescRef_ = &videoDescRef)
            {
                fixed (void* countRef_ = &countRef)
                {
                    __result__ =
                        SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)&guid, videoDescRef_, (void*)reservedRef, countRef_, &configsOut_, ((void**)(*(void**)_nativePointer))[6]);
                }
            }

            if(__result__.Success)
            {
                if(configsOut != null && configsOut_ != null)
                {
                    for(int i = 0; i < countRef && i < configsOut.Length; i++)
                    {
                        IntPtr ins = configsOut_ + i * Marshal.SizeOf(typeof(ConfigPictureDecode));
                        configsOut[i] = (ConfigPictureDecode)Marshal.PtrToStructure(ins, typeof(ConfigPictureDecode));
                    }

                }
            }

            return __result__.Success;
        }

        /// <summary>	
        /// <p> </p><p>Creates a video decoder device.</p>	
        /// </summary>	
        /// <param name="guid"><dd> <p><see cref="System.Guid"/> that specifies the decoder device to create. To get the available device GUIDs, call <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDecoderService.GetDecoderDeviceGuids"/></strong>.</p> </dd></param>	
        /// <param name="videoDescRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDesc"/></strong> structure that describes the video content.</p> </dd></param>	
        /// <param name="configRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.MediaFoundation.DirectX.ConfigPictureDecode"/></strong> structure that specifies the decoder configuration.</p> </dd></param>	
        /// <param name="decoderRenderTargetsOut"><dd> <p>Pointer to an array of <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> references containing references to the decoder render targets. To create these surfaces, call <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoAccelerationService.CreateSurface"/></strong>. Specify <see cref="SharpDX.MediaFoundation.DirectX.RenderTargetType.VideoDecoder"/> for the <em>DxvaType</em> parameter.</p> </dd></param>	
        /// <param name="numRenderTargets"><dd> <p>Size of the <em>ppDecoderRenderTargets</em> array. This value cannot be zero.</p> </dd></param>	
        /// <param name="decodeOut"><dd> <p>Receives a reference to the decoder's <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDecoder"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoDecoderService::CreateVideoDecoder']/*"/>	
        /// <msdn-id>ms696175</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoDecoderService::CreateVideoDecoder([In] const GUID&amp; Guid,[In] const DXVA2_VideoDesc* pVideoDesc,[In] const DXVA2_ConfigPictureDecode* pConfig,[In, Buffer] IDirect3DSurface9** ppDecoderRenderTargets,[In] unsigned int NumRenderTargets,[Out] IDirectXVideoDecoder** ppDecode)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoDecoderService::CreateVideoDecoder</unmanaged-short>	
        public bool CreateVideoDecoder(System.Guid guid, ref SharpDX.MediaFoundation.DirectX.VideoDesc videoDescRef, ref SharpDX.MediaFoundation.DirectX.ConfigPictureDecode configRef, SharpDX.Direct3D9.Surface[] decoderRenderTargetsOut, int numRenderTargets, out SharpDX.MediaFoundation.DirectX.VideoDecoder decodeOut) {
            unsafe {
                IntPtr* decoderRenderTargetsOut_ = (IntPtr*)0;
                if ( decoderRenderTargetsOut != null ) {
                    IntPtr* decoderRenderTargetsOut__ = stackalloc IntPtr[decoderRenderTargetsOut.Length];
                    decoderRenderTargetsOut_ = decoderRenderTargetsOut__;
                    for (int i = 0; i < decoderRenderTargetsOut.Length; i++)                        
                        decoderRenderTargetsOut_[i] =  (decoderRenderTargetsOut[i] == null)? IntPtr.Zero : decoderRenderTargetsOut[i].NativePointer;
                }
                IntPtr decodeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* videoDescRef_ = &videoDescRef)
                    fixed (void* configRef_ = &configRef)
                        __result__= 
        				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guid, videoDescRef_, configRef_, decoderRenderTargetsOut_, numRenderTargets, &decodeOut_,((void**)(*(void**)_nativePointer))[7]);		
                decodeOut= (decodeOut_ == IntPtr.Zero)?null:new SharpDX.MediaFoundation.DirectX.VideoDecoder(decodeOut_);
                return __result__.Success;
            }
        }
        
        /// <summary>	
        /// <p> </p><p>Creates a video decoder device.</p>	
        /// </summary>	
        /// <param name="guid"><dd> <p><see cref="System.Guid"/> that specifies the decoder device to create. To get the available device GUIDs, call <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDecoderService.GetDecoderDeviceGuids"/></strong>.</p> </dd></param>	
        /// <param name="videoDescRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDesc"/></strong> structure that describes the video content.</p> </dd></param>	
        /// <param name="configRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.MediaFoundation.DirectX.ConfigPictureDecode"/></strong> structure that specifies the decoder configuration.</p> </dd></param>	
        /// <param name="decoderRenderTargetsOut"><dd> <p>Pointer to an array of <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> references containing references to the decoder render targets. To create these surfaces, call <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoAccelerationService.CreateSurface"/></strong>. Specify <see cref="SharpDX.MediaFoundation.DirectX.RenderTargetType.VideoDecoder"/> for the <em>DxvaType</em> parameter.</p> </dd></param>	
        /// <param name="numRenderTargets"><dd> <p>Size of the <em>ppDecoderRenderTargets</em> array. This value cannot be zero.</p> </dd></param>	
        /// <param name="decodeOut"><dd> <p>Receives a reference to the decoder's <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDecoder"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoDecoderService::CreateVideoDecoder']/*"/>	
        /// <msdn-id>ms696175</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoDecoderService::CreateVideoDecoder([In] const GUID&amp; Guid,[In] const DXVA2_VideoDesc* pVideoDesc,[In] const DXVA2_ConfigPictureDecode* pConfig,[In, Buffer] IDirect3DSurface9** ppDecoderRenderTargets,[In] unsigned int NumRenderTargets,[Out] IDirectXVideoDecoder** ppDecode)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoDecoderService::CreateVideoDecoder</unmanaged-short>	
        public void CreateVideoDecoder(System.Guid guid, ref SharpDX.MediaFoundation.DirectX.VideoDesc videoDescRef, ref SharpDX.MediaFoundation.DirectX.ConfigPictureDecode configRef, SharpDX.ComArray<SharpDX.Direct3D9.Surface> decoderRenderTargetsOut, int numRenderTargets, out SharpDX.MediaFoundation.DirectX.VideoDecoder decodeOut) {
            unsafe {
                IntPtr decodeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* videoDescRef_ = &videoDescRef)
                    fixed (void* configRef_ = &configRef)
                        __result__= 
        				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guid, videoDescRef_, configRef_, (void*)((decoderRenderTargetsOut == null)?IntPtr.Zero:decoderRenderTargetsOut.NativePointer), numRenderTargets, &decodeOut_,((void**)(*(void**)_nativePointer))[7]);		
                decodeOut= (decodeOut_ == IntPtr.Zero)?null:new SharpDX.MediaFoundation.DirectX.VideoDecoder(decodeOut_);	
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Sets the type of video memory for uncompressed video surfaces. This interface is used by video decoders and transforms.</p><p>The DirectShow enhanced video renderer (EVR) filter exposes this interface as a service on the filter's input pins. To obtain a reference to this interface, call <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong> with the service identifier <see cref="SharpDX.MediaFoundation.MediaServiceKeys.VideoAcceleration"/>.</p><p>A video decoder can use this interface to enumerate the EVR filter's preferred surface types and then select the surface type. The decoder should then create surfaces of that type to hold the results of the decoding operation.</p><p>This interface does not define a way to clear the surface type. In the case of DirectShow, disconnecting two filters invalidates the surface type.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoMemoryConfiguration']/*"/>	
    /// <msdn-id>ms703164</msdn-id>	
    /// <unmanaged>IDirectXVideoMemoryConfiguration</unmanaged>	
    /// <unmanaged-short>IDirectXVideoMemoryConfiguration</unmanaged-short>	
    [Guid("b7f916dd-db3b-49c1-84d7-e45ef99ec726")]
    public partial class VideoMemoryConfiguration : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.DirectX.VideoMemoryConfiguration"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VideoMemoryConfiguration(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.DirectX.VideoMemoryConfiguration"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.MediaFoundation.DirectX.VideoMemoryConfiguration(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.DirectX.VideoMemoryConfiguration(nativePointer);
		}
        
        
        /// <summary>	
        /// <p> </p><p>Sets the video surface type that a decoder will use for DirectX Video Acceleration (DVXA) 2.0.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>By calling this method, the caller agrees to create surfaces of the type specified in the <em>dwType</em> parameter.</p><p>In DirectShow, during pin connection, a video decoder that supports DVXA 2.0 should call <strong>SetSurface</strong> with the value <see cref="SharpDX.MediaFoundation.DirectX.SurfaceType.SurfaceType_Decoder"/>. This notifies the video renderer that the decoder will provide the allocator and will create the Direct3D surfaces for decoding. For more information, see Supporting DXVA 2.0 in DirectShow.</p><p>The only way to undo the setting is to break the pin connection.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoMemoryConfiguration::SetSurfaceType']/*"/>	
        /// <msdn-id>ms693977</msdn-id>	
        /// <unmanaged>SetSurfaceType</unmanaged>	
        /// <unmanaged-short>SetSurfaceType</unmanaged-short>	
        /// <unmanaged>HRESULT IDirectXVideoMemoryConfiguration::SetSurfaceType([In] DXVA2_SurfaceType dwType)</unmanaged>
        public SharpDX.MediaFoundation.DirectX.SurfaceType SurfaceType {
                set { SetSurfaceType(value); }
        }
        
        /// <summary>	
        /// <p> </p><p>Retrieves a supported video surface type.</p>	
        /// </summary>	
        /// <param name="dwTypeIndex"><dd> <p>Zero-based index of the surface type to retrieve. Surface types are indexed in order of preference, starting with the most preferred type.</p> </dd></param>	
        /// <param name="dwTypeRef"><dd> <p>Receives a member of the <strong><see cref="SharpDX.MediaFoundation.DirectX.SurfaceType"/></strong> enumeration that specifies the surface type.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NoMoreTypes"/></strong></dt> </dl> </td><td> <p>The index was out of range.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoMemoryConfiguration::GetAvailableSurfaceTypeByIndex']/*"/>	
        /// <msdn-id>ms697493</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoMemoryConfiguration::GetAvailableSurfaceTypeByIndex([In] unsigned int dwTypeIndex,[Out] DXVA2_SurfaceType* pdwType)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoMemoryConfiguration::GetAvailableSurfaceTypeByIndex</unmanaged-short>	
        public void GetAvailableSurfaceTypeByIndex(int dwTypeIndex, out SharpDX.MediaFoundation.DirectX.SurfaceType dwTypeRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dwTypeRef_ = &dwTypeRef)
                    __result__= 
    				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwTypeIndex, dwTypeRef_,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> </p><p>Sets the video surface type that a decoder will use for DirectX Video Acceleration (DVXA) 2.0.</p>	
        /// </summary>	
        /// <param name="dwType"><dd> <p>Member of the <strong><see cref="SharpDX.MediaFoundation.DirectX.SurfaceType"/></strong> enumeration specifying the surface type. Currently, the only supported value is <see cref="SharpDX.MediaFoundation.DirectX.SurfaceType.SurfaceType_Decoder"/>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Win32.ErrorCode.UnsupportedType"/></strong></dt> </dl> </td><td> <p>The renderer does not support the specified surface type.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>By calling this method, the caller agrees to create surfaces of the type specified in the <em>dwType</em> parameter.</p><p>In DirectShow, during pin connection, a video decoder that supports DVXA 2.0 should call <strong>SetSurface</strong> with the value <see cref="SharpDX.MediaFoundation.DirectX.SurfaceType.SurfaceType_Decoder"/>. This notifies the video renderer that the decoder will provide the allocator and will create the Direct3D surfaces for decoding. For more information, see Supporting DXVA 2.0 in DirectShow.</p><p>The only way to undo the setting is to break the pin connection.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoMemoryConfiguration::SetSurfaceType']/*"/>	
        /// <msdn-id>ms693977</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoMemoryConfiguration::SetSurfaceType([In] DXVA2_SurfaceType dwType)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoMemoryConfiguration::SetSurfaceType</unmanaged-short>	
        internal void SetSurfaceType(SharpDX.MediaFoundation.DirectX.SurfaceType dwType) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)dwType),((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><p>Retrieves the parameters that were used to create this device.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>You can set any parameter to <strong><c>null</c></strong> if you are not interested in the result. At least one parameter must be non-<strong><c>null</c></strong>.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoProcessor']/*"/>	
    /// <msdn-id>ms704783</msdn-id>	
    /// <unmanaged>IDirectXVideoProcessor</unmanaged>	
    /// <unmanaged-short>IDirectXVideoProcessor</unmanaged-short>	
    [Guid("8c3a39f0-916e-4690-804f-4c8001355d25")]
    public partial class VideoProcessor : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.DirectX.VideoProcessor"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VideoProcessor(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.DirectX.VideoProcessor"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.MediaFoundation.DirectX.VideoProcessor(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.DirectX.VideoProcessor(nativePointer);
		}
        
        
        /// <summary>	
        /// <p> </p><p>Retrieves the DirectX Video Acceleration (DXVA) video processor service that created this video processor device.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoProcessor::GetVideoProcessorService']/*"/>	
        /// <msdn-id>ms700812</msdn-id>	
        /// <unmanaged>GetVideoProcessorService</unmanaged>	
        /// <unmanaged-short>GetVideoProcessorService</unmanaged-short>	
        /// <unmanaged>HRESULT IDirectXVideoProcessor::GetVideoProcessorService([Out] IDirectXVideoProcessorService** ppService)</unmanaged>
        public SharpDX.MediaFoundation.DirectX.VideoProcessorService VideoProcessorService {
                get { SharpDX.MediaFoundation.DirectX.VideoProcessorService __output__; GetVideoProcessorService(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p> </p><p>Retrieves the capabilities of the video processor device.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoProcessor::GetVideoProcessorCaps']/*"/>	
        /// <msdn-id>ms704831</msdn-id>	
        /// <unmanaged>GetVideoProcessorCaps</unmanaged>	
        /// <unmanaged-short>GetVideoProcessorCaps</unmanaged-short>	
        /// <unmanaged>HRESULT IDirectXVideoProcessor::GetVideoProcessorCaps([Out] DXVA2_VideoProcessorCaps* pCaps)</unmanaged>
        public SharpDX.MediaFoundation.DirectX.VideoProcessorCaps VideoProcessorCaps {
                get { SharpDX.MediaFoundation.DirectX.VideoProcessorCaps __output__; GetVideoProcessorCaps(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p> </p><p>Retrieves the DirectX Video Acceleration (DXVA) video processor service that created this video processor device.</p>	
        /// </summary>	
        /// <param name="serviceOut"><dd> <p>Receives a reference to <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoProcessorService"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoProcessor::GetVideoProcessorService']/*"/>	
        /// <msdn-id>ms700812</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoProcessor::GetVideoProcessorService([Out] IDirectXVideoProcessorService** ppService)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoProcessor::GetVideoProcessorService</unmanaged-short>	
        internal void GetVideoProcessorService(out SharpDX.MediaFoundation.DirectX.VideoProcessorService serviceOut) {
            unsafe {
                IntPtr serviceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &serviceOut_,((void**)(*(void**)_nativePointer))[3]);		
                serviceOut= (serviceOut_ == IntPtr.Zero)?null:new SharpDX.MediaFoundation.DirectX.VideoProcessorService(serviceOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> </p><p>Retrieves the parameters that were used to create this device.</p>	
        /// </summary>	
        /// <param name="deviceGuidRef"><dd> <p>Receives the device <see cref="System.Guid"/>. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="videoDescRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDesc"/></strong> structure allocated by the caller. The method fills the structure with a description of the video format. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="renderTargetFormatRef"><dd> <p>Receives the render target format, specified as a <strong><see cref="SharpDX.Direct3D9.Format"/></strong> value. For more information, see the Direct3D documentation. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="maxNumSubStreamsRef"><dd> <p>Receives the maximum number of streams supported by the device. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument. At least one parameter must be non-<strong><c>null</c></strong>.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>You can set any parameter to <strong><c>null</c></strong> if you are not interested in the result. At least one parameter must be non-<strong><c>null</c></strong>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoProcessor::GetCreationParameters']/*"/>	
        /// <msdn-id>ms704783</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoProcessor::GetCreationParameters([Out, Optional] GUID* pDeviceGuid,[Out, Optional] DXVA2_VideoDesc* pVideoDesc,[Out, Optional] D3DFORMAT* pRenderTargetFormat,[Out, Optional] unsigned int* pMaxNumSubStreams)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoProcessor::GetCreationParameters</unmanaged-short>	
        public void GetCreationParameters(out System.Guid deviceGuidRef, out SharpDX.MediaFoundation.DirectX.VideoDesc videoDescRef, out SharpDX.Direct3D9.Format renderTargetFormatRef, out int maxNumSubStreamsRef) {
            unsafe {
                deviceGuidRef = new System.Guid();
                videoDescRef = new SharpDX.MediaFoundation.DirectX.VideoDesc();
                SharpDX.Result __result__;
                fixed (void* deviceGuidRef_ = &deviceGuidRef)
                    fixed (void* videoDescRef_ = &videoDescRef)
                        fixed (void* renderTargetFormatRef_ = &renderTargetFormatRef)
                            fixed (void* maxNumSubStreamsRef_ = &maxNumSubStreamsRef)
                                __result__= 
                				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, deviceGuidRef_, videoDescRef_, renderTargetFormatRef_, maxNumSubStreamsRef_,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> </p><p>Retrieves the capabilities of the video processor device.</p>	
        /// </summary>	
        /// <param name="capsRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoProcessorCaps"/></strong> structure that receives the video processor capabilities.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoProcessor::GetVideoProcessorCaps']/*"/>	
        /// <msdn-id>ms704831</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoProcessor::GetVideoProcessorCaps([Out] DXVA2_VideoProcessorCaps* pCaps)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoProcessor::GetVideoProcessorCaps</unmanaged-short>	
        internal void GetVideoProcessorCaps(out SharpDX.MediaFoundation.DirectX.VideoProcessorCaps capsRef) {
            unsafe {
                capsRef = new SharpDX.MediaFoundation.DirectX.VideoProcessorCaps();
                SharpDX.Result __result__;
                fixed (void* capsRef_ = &capsRef)
                    __result__= 
    				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, capsRef_,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> </p><p>Retrieves the range of values for a video processor (ProcAmp) setting on this video processor device.</p>	
        /// </summary>	
        /// <param name="procAmpCap"><dd> <p>The ProcAmp setting to query. See ProcAmp Settings.</p> </dd></param>	
        /// <param name="rangeRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.MediaFoundation.DirectX.ValueRange"/></strong> structure that receives the range of values for the setting specified in <em>ProcAmpCaps</em>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoProcessor::GetProcAmpRange']/*"/>	
        /// <msdn-id>ms704610</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoProcessor::GetProcAmpRange([In] unsigned int ProcAmpCap,[Out] DXVA2_ValueRange* pRange)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoProcessor::GetProcAmpRange</unmanaged-short>	
        public void GetProcAmpRange(int procAmpCap, out SharpDX.MediaFoundation.DirectX.ValueRange rangeRef) {
            unsafe {
                rangeRef = new SharpDX.MediaFoundation.DirectX.ValueRange();
                SharpDX.Result __result__;
                fixed (void* rangeRef_ = &rangeRef)
                    __result__= 
    				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, procAmpCap, rangeRef_,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> </p><p>Retrieves the range of values for an image filter supported by this device.</p>	
        /// </summary>	
        /// <param name="filterSetting"><dd> <p>Filter setting to query. For more information, see DXVA Image Filter Settings.</p> </dd></param>	
        /// <param name="rangeRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.MediaFoundation.DirectX.ValueRange"/></strong> structure that receives the range of values for the setting specified in <em>FilterSetting</em>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoProcessor::GetFilterPropertyRange']/*"/>	
        /// <msdn-id>ms697209</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoProcessor::GetFilterPropertyRange([In] unsigned int FilterSetting,[Out] DXVA2_ValueRange* pRange)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoProcessor::GetFilterPropertyRange</unmanaged-short>	
        public void GetFilterPropertyRange(int filterSetting, out SharpDX.MediaFoundation.DirectX.ValueRange rangeRef) {
            unsafe {
                rangeRef = new SharpDX.MediaFoundation.DirectX.ValueRange();
                SharpDX.Result __result__;
                fixed (void* rangeRef_ = &rangeRef)
                    __result__= 
    				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, filterSetting, rangeRef_,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Performs a video process operation on one or more input samples and writes the result to a Direct3D9 surface. </p>	
        /// </summary>	
        /// <param name="renderTargetRef"><dd> <p> A reference to the <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface of a Direct3D surface. The output of the video processing operation will be written to this surface. The surface may be any of the following types: </p> <ul> <li> A surface created by calling <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoAccelerationService.CreateSurface"/></strong> with the <strong>DXVA2_VideoProcessRenderTarget</strong> flag. You can also use the <strong><see cref="SharpDX.MediaFoundation.DirectX.RenderTargetType.VideoSoftware"/></strong> flag, but only when the device <see cref="System.Guid"/> is <strong>DXVA2_VideoProcSoftwareDevice</strong> (software video processing device). </li> <li> A surface created from a Direct3D device with the <strong><see cref="SharpDX.Direct3D9.Usage.RenderTarget"/></strong> usage flag. </li> <li> A Direct3D swap chain. </li> </ul> </dd></param>	
        /// <param name="bltParamsRef"><dd> <p>A reference to a <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoProcessBltParams"/></strong> structure that describes the video processing operation to perform. </p> </dd></param>	
        /// <param name="samplesRef"><dd> <p>A reference to an array of <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoSample"/></strong> structures that contain the input samples. There must be at least one element in the array.</p> <p>The maximum number of input samples is given by the constant <strong>MAX_DEINTERLACE_SURFACES</strong>, defined in the header file dxva2api.h.</p> </dd></param>	
        /// <param name="numSamples"><dd> <p>The number of elements in the <em>pSamples</em> array. </p> </dd></param>	
        /// <param name="handleCompleteRef"><dd> <p>Reserved; set to <strong><c>null</c></strong>. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Direct3D9.ResultCode.DriverInternalError"/></strong></dt> </dl> </td><td> <p>Internal driver error.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p> Invalid arguments.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> When the method returns, the operation might not be complete. </p><p>If the method returns <strong>E_INVALIDARG</strong>, check for the following:</p><ul> <li>The number of input samples (<em>NumSamples</em>) must be less than or equal to <strong>MAX_DEINTERLACE_SURFACES</strong>. </li> <li>The Direct3D surface must be a valid target for <strong>VideoProcessBlt</strong>. See the description of the <em>pRT</em> parameter for details.</li> <li>The presentation time (<strong>TargetFrame</strong>) given in <em>pBltParams</em> must match the start and end times for the current picture from the primary stream. Specifically, it must be less than the end time and greater than or equal to the start time. Note that the first sample in <em>pSamples</em> might not be the current picture, if the <em>pSamples</em> array contains backward reference pictures. For more information, see Input Sample Order.</li> <li>The target rectangle (<strong>TargetRect</strong>) given in <em>pBltParams</em> cannot be larger than the destination surface (<em>pRT</em>).</li> <li>The  constriction size (<strong>ConstrictionSize</strong>) given in <em>pBltParams</em> cannot be less than zero or larger than the target rectangle.</li> <li>The alpha component of the background color must be opqaue.</li> <li>The ProcAmp values given in <em>pBltParams</em> must be valid. For any ProcAmp settings that are supported by the driver, these values must fall within the ranges returned by the <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoProcessor.GetProcAmpRange"/></strong> method.</li> <li>The noise and detail filters given in <em>pBltParams</em> must be valid. For any filters that are supported by the driver, these values must fall within the ranges returned by the <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoProcessor.GetFilterPropertyRange"/></strong> method.</li> <li>The alpha value given in <em>pBltParams</em> must be in the range [0...1] inclusive.</li> <li>For each input sample given in <em>pSamples</em>:<ul> <li>The start time cannot be greater than the end time.</li> <li>A valid <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> reference must be provided.</li> <li>The source rectangle cannot be larger than the input surface.</li> <li>The destination rectangle cannot be larger than than the destination surface.</li> <li>The planar alpha must be in the range [0...1] inclusive.</li> </ul> </li> <li> For all rectangles (source, destination, and target),  the rectangle cannot be inverted (left &gt; right or top &gt; bottom) or have negative values.</li> </ul>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoProcessor::VideoProcessBlt']/*"/>	
        /// <msdn-id>ms697022</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoProcessor::VideoProcessBlt([In] IDirect3DSurface9* pRenderTarget,[In] const DXVA2_VideoProcessBltParams* pBltParams,[In, Buffer] const DXVA2_VideoSample* pSamples,[In] unsigned int NumSamples,[InOut, Optional] void** pHandleComplete)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoProcessor::VideoProcessBlt</unmanaged-short>	
        public void VideoProcessBlt(SharpDX.Direct3D9.Surface renderTargetRef, ref SharpDX.MediaFoundation.DirectX.VideoProcessBltParams bltParamsRef, SharpDX.MediaFoundation.DirectX.VideoSample[] samplesRef, int numSamples, System.IntPtr handleCompleteRef) {
            unsafe {
                SharpDX.MediaFoundation.DirectX.VideoSample.__Native[] samplesRef__ = new SharpDX.MediaFoundation.DirectX.VideoSample.__Native[samplesRef.Length];
                for (int i = 0; i < samplesRef.Length; i++)
                    samplesRef[i].__MarshalTo(ref samplesRef__[i]);				
                SharpDX.Result __result__;
                fixed (void* bltParamsRef_ = &bltParamsRef)
                    fixed (void* samplesRef_ = samplesRef__)
                        __result__= 
        				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((renderTargetRef == null)?IntPtr.Zero:renderTargetRef.NativePointer), bltParamsRef_, samplesRef_, numSamples, (void*)handleCompleteRef,((void**)(*(void**)_nativePointer))[8]);		
                for (int i = 0; i < samplesRef.Length; i++)
                    samplesRef[i].__MarshalFree(ref samplesRef__[i]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides access to DirectX Video Acceleration (DXVA) video processing services.</p><p>Use this interface to query which hardware-accelerated video processing operations are available and to create DXVA video processor devices. To obtain a reference to this interface, call <strong><see cref="SharpDX.MediaFoundation.DirectX.Direct3DDeviceManager.GetVideoService"/></strong> or <strong><see cref="SharpDX.MediaFoundation.DirectX.DXVAFactory.CreateVideoService"/></strong> with the interface identifier <strong>IID_IDirectXVideoProcessorService</strong>.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoProcessorService']/*"/>	
    /// <msdn-id>ms705631</msdn-id>	
    /// <unmanaged>IDirectXVideoProcessorService</unmanaged>	
    /// <unmanaged-short>IDirectXVideoProcessorService</unmanaged-short>	
    [Guid("fc51a552-d5e7-11d9-af55-00054e43ff02")]
    public partial class VideoProcessorService : SharpDX.MediaFoundation.DirectX.VideoAccelerationService {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.DirectX.VideoProcessorService"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VideoProcessorService(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.DirectX.VideoProcessorService"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.MediaFoundation.DirectX.VideoProcessorService(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.DirectX.VideoProcessorService(nativePointer);
		}
        
        
        /// <summary>	
        /// <p> </p><p>Registers a software video processing device.</p>	
        /// </summary>	
        /// <param name="callbacksRef"><dd> <p>Pointer to an initialization function.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoProcessorService::RegisterVideoProcessorSoftwareDevice']/*"/>	
        /// <msdn-id>ms696262</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoProcessorService::RegisterVideoProcessorSoftwareDevice([In] void* pCallbacks)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoProcessorService::RegisterVideoProcessorSoftwareDevice</unmanaged-short>	
        public void RegisterVideoProcessorSoftwareDevice(System.IntPtr callbacksRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)callbacksRef,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Gets an array of GUIDs which identify the video processors supported by the graphics hardware. </p>	
        /// </summary>	
        /// <param name="videoDescRef"><dd> <p> Pointer to a <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDesc"/></strong> structure that describes the video content. </p> </dd></param>	
        /// <param name="countRef"><dd> <p> Receives the number of GUIDs. </p> </dd></param>	
        /// <param name="guidsRef"><dd> <p> Receives an array of GUIDs. The size of the array is retrieved in the <em>pCount</em> parameter. The method allocates the memory for the array. The caller must free the memory by calling <strong>CoTaskMemFree</strong>. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The following video processor GUIDs are predefined.</p><table> <tr><th><see cref="System.Guid"/></th><th>Description</th></tr> <tr><td><strong>DXVA2_VideoProcBobDevice</strong></td><td>Bob deinterlace device. This device uses a "bob" algorithm to deinterlace the video. Bob algorithms create missing field lines by interpolating the lines in a single field.</td></tr> <tr><td><strong>DXVA2_VideoProcProgressiveDevice</strong></td><td>Progressive video device. This device is available for progressive video, which does not require a deinterlace algorithm.</td></tr> <tr><td><strong>DXVA2_VideoProcSoftwareDevice</strong></td><td>Reference (software) device.</td></tr> </table><p>?</p><p>The graphics device may define additional vendor-specific GUIDs. The driver provides the list of GUIDs in descending quality order. The mode with the highest quality is first in the list. To get the capabilities of each mode, call <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoProcessorService.GetVideoProcessorCaps"/></strong> and pass in the <see cref="System.Guid"/> for the mode.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoProcessorService::GetVideoProcessorDeviceGuids']/*"/>	
        /// <msdn-id>ms695370</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoProcessorService::GetVideoProcessorDeviceGuids([In] const DXVA2_VideoDesc* pVideoDesc,[Out] unsigned int* pCount,[Out, Buffer, Optional] GUID** pGuids)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoProcessorService::GetVideoProcessorDeviceGuids</unmanaged-short>	
        public void GetVideoProcessorDeviceGuids(ref SharpDX.MediaFoundation.DirectX.VideoDesc videoDescRef, out int countRef, System.Guid[] guidsRef) {
            unsafe {
                System.Guid[] guidsRef__ = guidsRef;
                SharpDX.Result __result__;
                fixed (void* videoDescRef_ = &videoDescRef)
                    fixed (void* countRef_ = &countRef)
                        fixed (void* guidsRef_ = guidsRef__)
                            __result__= 
            				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, videoDescRef_, countRef_, guidsRef_,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Gets the render target formats that a video processor device supports. The list may include RGB and YUV formats. </p>	
        /// </summary>	
        /// <param name="videoProcDeviceGuid"><dd> <p> A <see cref="System.Guid"/> that identifies the video processor device. To get the list of video processor GUIDs, call <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoProcessorService.GetVideoProcessorDeviceGuids"/></strong>.</p> </dd></param>	
        /// <param name="videoDescRef"><dd> <p> A reference to a <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDesc"/></strong> structure that describes the video content. </p> </dd></param>	
        /// <param name="countRef"><dd> <p> Receives the number of formats. </p> </dd></param>	
        /// <param name="formatsRef"><dd> <p> Receives an array of formats, specified as <strong><see cref="SharpDX.Direct3D9.Format"/></strong> values. The size of the array is retrieved in the <em>pCount</em> parameter. The method allocates the memory for the array. The caller must free the memory by calling <strong>CoTaskMemFree</strong>. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoProcessorService::GetVideoProcessorRenderTargets']/*"/>	
        /// <msdn-id>ms702118</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoProcessorService::GetVideoProcessorRenderTargets([In] const GUID&amp; VideoProcDeviceGuid,[In] const DXVA2_VideoDesc* pVideoDesc,[Out] unsigned int* pCount,[Out, Buffer, Optional] D3DFORMAT** pFormats)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoProcessorService::GetVideoProcessorRenderTargets</unmanaged-short>	
        public void GetVideoProcessorRenderTargets(System.Guid videoProcDeviceGuid, ref SharpDX.MediaFoundation.DirectX.VideoDesc videoDescRef, out int countRef, SharpDX.Direct3D9.Format[] formatsRef) {
            unsafe {
                SharpDX.Direct3D9.Format[] formatsRef__ = formatsRef;
                SharpDX.Result __result__;
                fixed (void* videoDescRef_ = &videoDescRef)
                    fixed (void* countRef_ = &countRef)
                        fixed (void* formatsRef_ = formatsRef__)
                            __result__= 
            				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)&videoProcDeviceGuid, videoDescRef_, countRef_, formatsRef_,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Gets a list of substream formats supported by a specified video processor device. </p>	
        /// </summary>	
        /// <param name="videoProcDeviceGuid"><dd> <p> A <see cref="System.Guid"/> that identifies the video processor device.  To get the list of video processor GUIDs, call <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoProcessorService.GetVideoProcessorDeviceGuids"/></strong>.</p> </dd></param>	
        /// <param name="videoDescRef"><dd> <p> A reference to a <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDesc"/></strong> structure that describes the video content. </p> </dd></param>	
        /// <param name="renderTargetFormat"><dd> <p> The format of the render target surface, specified as a <strong><see cref="SharpDX.Direct3D9.Format"/></strong> value. For more information, see the Direct3D documentation. You can also use a FOURCC code to specify a format that is not defined in the <strong><see cref="SharpDX.Direct3D9.Format"/></strong> enumeration. See Video FOURCCs. </p> </dd></param>	
        /// <param name="countRef"><dd> <p> Receives the number of elements returned in the <em>ppFormats</em> array. </p> </dd></param>	
        /// <param name="formatsRef"><dd> <p> Receives an array of <strong><see cref="SharpDX.Direct3D9.Format"/></strong> values. The caller must free the array by calling <strong>CoTaskMemFree</strong>. The array can contain both RGB and YUB pixel formats. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoProcessorService::GetVideoProcessorSubStreamFormats']/*"/>	
        /// <msdn-id>ms694271</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoProcessorService::GetVideoProcessorSubStreamFormats([In] const GUID&amp; VideoProcDeviceGuid,[In] const DXVA2_VideoDesc* pVideoDesc,[In] D3DFORMAT RenderTargetFormat,[Out] unsigned int* pCount,[Out, Buffer, Optional] D3DFORMAT** pFormats)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoProcessorService::GetVideoProcessorSubStreamFormats</unmanaged-short>	
        public void GetVideoProcessorSubStreamFormats(System.Guid videoProcDeviceGuid, ref SharpDX.MediaFoundation.DirectX.VideoDesc videoDescRef, SharpDX.Direct3D9.Format renderTargetFormat, out int countRef, SharpDX.Direct3D9.Format[] formatsRef) {
            unsafe {
                SharpDX.Direct3D9.Format[] formatsRef__ = formatsRef;
                SharpDX.Result __result__;
                fixed (void* videoDescRef_ = &videoDescRef)
                    fixed (void* countRef_ = &countRef)
                        fixed (void* formatsRef_ = formatsRef__)
                            __result__= 
            				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)&videoProcDeviceGuid, videoDescRef_, unchecked((int)renderTargetFormat), countRef_, formatsRef_,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Gets the capabilities of a specified video processor device. </p>	
        /// </summary>	
        /// <param name="videoProcDeviceGuid"><dd> <p> A <see cref="System.Guid"/> that identifies the video processor device. To get the list of video processor GUIDs, call <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoProcessorService.GetVideoProcessorDeviceGuids"/></strong>.</p> </dd></param>	
        /// <param name="videoDescRef"><dd> <p> A reference to a <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDesc"/></strong> structure that describes the video content. </p> </dd></param>	
        /// <param name="renderTargetFormat"><dd> <p> The format of the render target surface, specified as a <strong><see cref="SharpDX.Direct3D9.Format"/></strong> value. For more information, see the Direct3D documentation. You can also use a FOURCC code to specify a format that is not defined in the <strong><see cref="SharpDX.Direct3D9.Format"/></strong> enumeration. See Video FOURCCs. </p> </dd></param>	
        /// <param name="capsRef"><dd> <p> A reference to a <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoProcessorCaps"/></strong> structure that receives the video processor capabilities. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoProcessorService::GetVideoProcessorCaps']/*"/>	
        /// <msdn-id>ms702988</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoProcessorService::GetVideoProcessorCaps([In] const GUID&amp; VideoProcDeviceGuid,[In] const DXVA2_VideoDesc* pVideoDesc,[In] D3DFORMAT RenderTargetFormat,[Out] DXVA2_VideoProcessorCaps* pCaps)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoProcessorService::GetVideoProcessorCaps</unmanaged-short>	
        public void GetVideoProcessorCaps(System.Guid videoProcDeviceGuid, ref SharpDX.MediaFoundation.DirectX.VideoDesc videoDescRef, SharpDX.Direct3D9.Format renderTargetFormat, out SharpDX.MediaFoundation.DirectX.VideoProcessorCaps capsRef) {
            unsafe {
                capsRef = new SharpDX.MediaFoundation.DirectX.VideoProcessorCaps();
                SharpDX.Result __result__;
                fixed (void* videoDescRef_ = &videoDescRef)
                    fixed (void* capsRef_ = &capsRef)
                        __result__= 
        				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)&videoProcDeviceGuid, videoDescRef_, unchecked((int)renderTargetFormat), capsRef_,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Gets the range of values for a video processor (ProcAmp) setting. </p>	
        /// </summary>	
        /// <param name="videoProcDeviceGuid"><dd> <p>A  <see cref="System.Guid"/> that identifies the video processor device. To get the list of video processor GUIDs, call <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoProcessorService.GetVideoProcessorDeviceGuids"/></strong>.</p> </dd></param>	
        /// <param name="videoDescRef"><dd> <p> A reference to a <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDesc"/></strong> structure that describes the video content. </p> </dd></param>	
        /// <param name="renderTargetFormat"><dd> <p> The format of the render target surface, specified as a <strong><see cref="SharpDX.Direct3D9.Format"/></strong> value. For more information, see the Direct3D documentation. You can also use a FOURCC code to specify a format that is not defined in the <strong><see cref="SharpDX.Direct3D9.Format"/></strong> enumeration. See Video FOURCCs. </p> </dd></param>	
        /// <param name="procAmpCap"><dd> <p>The  ProcAmp setting to query. See ProcAmp Settings. </p> </dd></param>	
        /// <param name="rangeRef"><dd> <p> A reference to a <strong><see cref="SharpDX.MediaFoundation.DirectX.ValueRange"/></strong> structure that receives the range of values for the setting specified in <em>ProcAmpCaps</em>. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoProcessorService::GetProcAmpRange']/*"/>	
        /// <msdn-id>ms702244</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoProcessorService::GetProcAmpRange([In] const GUID&amp; VideoProcDeviceGuid,[In] const DXVA2_VideoDesc* pVideoDesc,[In] D3DFORMAT RenderTargetFormat,[In] unsigned int ProcAmpCap,[Out] DXVA2_ValueRange* pRange)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoProcessorService::GetProcAmpRange</unmanaged-short>	
        public void GetProcAmpRange(System.Guid videoProcDeviceGuid, ref SharpDX.MediaFoundation.DirectX.VideoDesc videoDescRef, SharpDX.Direct3D9.Format renderTargetFormat, int procAmpCap, out SharpDX.MediaFoundation.DirectX.ValueRange rangeRef) {
            unsafe {
                rangeRef = new SharpDX.MediaFoundation.DirectX.ValueRange();
                SharpDX.Result __result__;
                fixed (void* videoDescRef_ = &videoDescRef)
                    fixed (void* rangeRef_ = &rangeRef)
                        __result__= 
        				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &videoProcDeviceGuid, videoDescRef_, unchecked((int)renderTargetFormat), procAmpCap, rangeRef_,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Retrieves the range of values for an image filter supported by a video processor device. </p>	
        /// </summary>	
        /// <param name="videoProcDeviceGuid"><dd> <p> A <see cref="System.Guid"/> that identifies the video processor device. To get the list of video processor GUIDs, call <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoProcessorService.GetVideoProcessorDeviceGuids"/></strong>.</p> </dd></param>	
        /// <param name="videoDescRef"><dd> <p> A reference to a <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDesc"/></strong> structure that describes the video content. </p> </dd></param>	
        /// <param name="renderTargetFormat"><dd> <p> The format of the render target surface, specified as a <strong><see cref="SharpDX.Direct3D9.Format"/></strong> value. For more information, see the Direct3D documentation. You can also use a FOURCC code to specify a format that is not defined in the <strong><see cref="SharpDX.Direct3D9.Format"/></strong> enumeration. See Video FOURCCs. </p> </dd></param>	
        /// <param name="filterSetting"><dd> <p>The filter setting to query. See DXVA Image Filter Settings. </p> </dd></param>	
        /// <param name="rangeRef"><dd> <p> A reference to a <strong><see cref="SharpDX.MediaFoundation.DirectX.ValueRange"/></strong> structure that receives range of values for the image filter setting specified in <em>FilterSetting</em>. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoProcessorService::GetFilterPropertyRange']/*"/>	
        /// <msdn-id>ms694173</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoProcessorService::GetFilterPropertyRange([In] const GUID&amp; VideoProcDeviceGuid,[In] const DXVA2_VideoDesc* pVideoDesc,[In] D3DFORMAT RenderTargetFormat,[In] unsigned int FilterSetting,[Out] DXVA2_ValueRange* pRange)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoProcessorService::GetFilterPropertyRange</unmanaged-short>	
        public void GetFilterPropertyRange(System.Guid videoProcDeviceGuid, ref SharpDX.MediaFoundation.DirectX.VideoDesc videoDescRef, SharpDX.Direct3D9.Format renderTargetFormat, int filterSetting, out SharpDX.MediaFoundation.DirectX.ValueRange rangeRef) {
            unsafe {
                rangeRef = new SharpDX.MediaFoundation.DirectX.ValueRange();
                SharpDX.Result __result__;
                fixed (void* videoDescRef_ = &videoDescRef)
                    fixed (void* rangeRef_ = &rangeRef)
                        __result__= 
        				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &videoProcDeviceGuid, videoDescRef_, unchecked((int)renderTargetFormat), filterSetting, rangeRef_,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates a video processor device. </p>	
        /// </summary>	
        /// <param name="videoProcDeviceGuid"><dd> <p>A <see cref="System.Guid"/> that specifies the video processor to create. To get the list of video processor GUIDs, call <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoProcessorService.GetVideoProcessorDeviceGuids"/></strong>.</p> </dd></param>	
        /// <param name="videoDescRef"><dd> <p> A reference to a <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoDesc"/></strong> structure that describes the video content. </p> </dd></param>	
        /// <param name="renderTargetFormat"><dd> <p>The format of the render target surface, specified as a <strong><see cref="SharpDX.Direct3D9.Format"/></strong> value. For more information, see the Direct3D documentation. You can also use a FOURCC code to specify a format that is not defined in the <strong><see cref="SharpDX.Direct3D9.Format"/></strong> enumeration. See Video FOURCCs.</p> </dd></param>	
        /// <param name="maxNumSubStreams"><dd> <p> The maximum number of substreams that will be used with this device. </p> </dd></param>	
        /// <param name="vidProcessOut"><dd> <p> Receives a reference to the video processor's <strong><see cref="SharpDX.MediaFoundation.DirectX.VideoProcessor"/></strong> interface. The caller must release the interface. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectXVideoProcessorService::CreateVideoProcessor']/*"/>	
        /// <msdn-id>ms694848</msdn-id>	
        /// <unmanaged>HRESULT IDirectXVideoProcessorService::CreateVideoProcessor([In] const GUID&amp; VideoProcDeviceGuid,[In] const DXVA2_VideoDesc* pVideoDesc,[In] D3DFORMAT RenderTargetFormat,[In] unsigned int MaxNumSubStreams,[Out] IDirectXVideoProcessor** ppVidProcess)</unmanaged>	
        /// <unmanaged-short>IDirectXVideoProcessorService::CreateVideoProcessor</unmanaged-short>	
        public void CreateVideoProcessor(System.Guid videoProcDeviceGuid, ref SharpDX.MediaFoundation.DirectX.VideoDesc videoDescRef, SharpDX.Direct3D9.Format renderTargetFormat, int maxNumSubStreams, out SharpDX.MediaFoundation.DirectX.VideoProcessor vidProcessOut) {
            unsafe {
                IntPtr vidProcessOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* videoDescRef_ = &videoDescRef)
                    __result__= 
    				SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &videoProcDeviceGuid, videoDescRef_, unchecked((int)renderTargetFormat), maxNumSubStreams, &vidProcessOut_,((void**)(*(void**)_nativePointer))[11]);		
                vidProcessOut= (vidProcessOut_ == IntPtr.Zero)?null:new SharpDX.MediaFoundation.DirectX.VideoProcessor(vidProcessOut_);	
                __result__.CheckError();
            }
        }
    }
}
#endif